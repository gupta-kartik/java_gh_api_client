/*
 * GitHub v3 REST API
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.BasicError;
import org.openapitools.client.model.ModelPackage;
import org.openapitools.client.model.PackageVersion;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class PackagesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public PackagesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public PackagesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for packagesDeletePackageForAuthenticatedUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-the-authenticated-user">Delete a package for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageForAuthenticatedUserCall(String packageType, String packageName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/packages/{package_type}/{package_name}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesDeletePackageForAuthenticatedUserValidateBeforeCall(String packageType, String packageName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesDeletePackageForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesDeletePackageForAuthenticatedUser(Async)");
        }

        return packagesDeletePackageForAuthenticatedUserCall(packageType, packageName, _callback);

    }

    /**
     * Delete a package for the authenticated user
     * Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-the-authenticated-user">Delete a package for the authenticated user Documentation</a>
     */
    public void packagesDeletePackageForAuthenticatedUser(String packageType, String packageName) throws ApiException {
        packagesDeletePackageForAuthenticatedUserWithHttpInfo(packageType, packageName);
    }

    /**
     * Delete a package for the authenticated user
     * Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-the-authenticated-user">Delete a package for the authenticated user Documentation</a>
     */
    public ApiResponse<Void> packagesDeletePackageForAuthenticatedUserWithHttpInfo(String packageType, String packageName) throws ApiException {
        okhttp3.Call localVarCall = packagesDeletePackageForAuthenticatedUserValidateBeforeCall(packageType, packageName, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a package for the authenticated user (asynchronously)
     * Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-the-authenticated-user">Delete a package for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageForAuthenticatedUserAsync(String packageType, String packageName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesDeletePackageForAuthenticatedUserValidateBeforeCall(packageType, packageName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesDeletePackageForOrg
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-an-organization">Delete a package for an organization Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageForOrgCall(String packageType, String packageName, String org, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/packages/{package_type}/{package_name}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesDeletePackageForOrgValidateBeforeCall(String packageType, String packageName, String org, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesDeletePackageForOrg(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesDeletePackageForOrg(Async)");
        }

        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesDeletePackageForOrg(Async)");
        }

        return packagesDeletePackageForOrgCall(packageType, packageName, org, _callback);

    }

    /**
     * Delete a package for an organization
     * Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-an-organization">Delete a package for an organization Documentation</a>
     */
    public void packagesDeletePackageForOrg(String packageType, String packageName, String org) throws ApiException {
        packagesDeletePackageForOrgWithHttpInfo(packageType, packageName, org);
    }

    /**
     * Delete a package for an organization
     * Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-an-organization">Delete a package for an organization Documentation</a>
     */
    public ApiResponse<Void> packagesDeletePackageForOrgWithHttpInfo(String packageType, String packageName, String org) throws ApiException {
        okhttp3.Call localVarCall = packagesDeletePackageForOrgValidateBeforeCall(packageType, packageName, org, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a package for an organization (asynchronously)
     * Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-an-organization">Delete a package for an organization Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageForOrgAsync(String packageType, String packageName, String org, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesDeletePackageForOrgValidateBeforeCall(packageType, packageName, org, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesDeletePackageForUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-a-user">Delete a package for a user Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageForUserCall(String packageType, String packageName, String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/packages/{package_type}/{package_name}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesDeletePackageForUserValidateBeforeCall(String packageType, String packageName, String username, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesDeletePackageForUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesDeletePackageForUser(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesDeletePackageForUser(Async)");
        }

        return packagesDeletePackageForUserCall(packageType, packageName, username, _callback);

    }

    /**
     * Delete a package for a user
     * Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-a-user">Delete a package for a user Documentation</a>
     */
    public void packagesDeletePackageForUser(String packageType, String packageName, String username) throws ApiException {
        packagesDeletePackageForUserWithHttpInfo(packageType, packageName, username);
    }

    /**
     * Delete a package for a user
     * Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-a-user">Delete a package for a user Documentation</a>
     */
    public ApiResponse<Void> packagesDeletePackageForUserWithHttpInfo(String packageType, String packageName, String username) throws ApiException {
        okhttp3.Call localVarCall = packagesDeletePackageForUserValidateBeforeCall(packageType, packageName, username, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a package for a user (asynchronously)
     * Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-for-a-user">Delete a package for a user Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageForUserAsync(String packageType, String packageName, String username, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesDeletePackageForUserValidateBeforeCall(packageType, packageName, username, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesDeletePackageVersionForAuthenticatedUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-the-authenticated-user">Delete a package version for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageVersionForAuthenticatedUserCall(String packageType, String packageName, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesDeletePackageVersionForAuthenticatedUserValidateBeforeCall(String packageType, String packageName, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesDeletePackageVersionForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesDeletePackageVersionForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesDeletePackageVersionForAuthenticatedUser(Async)");
        }

        return packagesDeletePackageVersionForAuthenticatedUserCall(packageType, packageName, packageVersionId, _callback);

    }

    /**
     * Delete a package version for the authenticated user
     * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-the-authenticated-user">Delete a package version for the authenticated user Documentation</a>
     */
    public void packagesDeletePackageVersionForAuthenticatedUser(String packageType, String packageName, Integer packageVersionId) throws ApiException {
        packagesDeletePackageVersionForAuthenticatedUserWithHttpInfo(packageType, packageName, packageVersionId);
    }

    /**
     * Delete a package version for the authenticated user
     * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-the-authenticated-user">Delete a package version for the authenticated user Documentation</a>
     */
    public ApiResponse<Void> packagesDeletePackageVersionForAuthenticatedUserWithHttpInfo(String packageType, String packageName, Integer packageVersionId) throws ApiException {
        okhttp3.Call localVarCall = packagesDeletePackageVersionForAuthenticatedUserValidateBeforeCall(packageType, packageName, packageVersionId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a package version for the authenticated user (asynchronously)
     * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-the-authenticated-user">Delete a package version for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageVersionForAuthenticatedUserAsync(String packageType, String packageName, Integer packageVersionId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesDeletePackageVersionForAuthenticatedUserValidateBeforeCall(packageType, packageName, packageVersionId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesDeletePackageVersionForOrg
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-an-organization">Delete package version for an organization Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageVersionForOrgCall(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesDeletePackageVersionForOrgValidateBeforeCall(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesDeletePackageVersionForOrg(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesDeletePackageVersionForOrg(Async)");
        }

        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesDeletePackageVersionForOrg(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesDeletePackageVersionForOrg(Async)");
        }

        return packagesDeletePackageVersionForOrgCall(packageType, packageName, org, packageVersionId, _callback);

    }

    /**
     * Delete package version for an organization
     * Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-an-organization">Delete package version for an organization Documentation</a>
     */
    public void packagesDeletePackageVersionForOrg(String packageType, String packageName, String org, Integer packageVersionId) throws ApiException {
        packagesDeletePackageVersionForOrgWithHttpInfo(packageType, packageName, org, packageVersionId);
    }

    /**
     * Delete package version for an organization
     * Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-an-organization">Delete package version for an organization Documentation</a>
     */
    public ApiResponse<Void> packagesDeletePackageVersionForOrgWithHttpInfo(String packageType, String packageName, String org, Integer packageVersionId) throws ApiException {
        okhttp3.Call localVarCall = packagesDeletePackageVersionForOrgValidateBeforeCall(packageType, packageName, org, packageVersionId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete package version for an organization (asynchronously)
     * Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-an-organization">Delete package version for an organization Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageVersionForOrgAsync(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesDeletePackageVersionForOrgValidateBeforeCall(packageType, packageName, org, packageVersionId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesDeletePackageVersionForUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-a-user">Delete package version for a user Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageVersionForUserCall(String packageType, String packageName, String username, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesDeletePackageVersionForUserValidateBeforeCall(String packageType, String packageName, String username, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesDeletePackageVersionForUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesDeletePackageVersionForUser(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesDeletePackageVersionForUser(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesDeletePackageVersionForUser(Async)");
        }

        return packagesDeletePackageVersionForUserCall(packageType, packageName, username, packageVersionId, _callback);

    }

    /**
     * Delete package version for a user
     * Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-a-user">Delete package version for a user Documentation</a>
     */
    public void packagesDeletePackageVersionForUser(String packageType, String packageName, String username, Integer packageVersionId) throws ApiException {
        packagesDeletePackageVersionForUserWithHttpInfo(packageType, packageName, username, packageVersionId);
    }

    /**
     * Delete package version for a user
     * Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-a-user">Delete package version for a user Documentation</a>
     */
    public ApiResponse<Void> packagesDeletePackageVersionForUserWithHttpInfo(String packageType, String packageName, String username, Integer packageVersionId) throws ApiException {
        okhttp3.Call localVarCall = packagesDeletePackageVersionForUserValidateBeforeCall(packageType, packageName, username, packageVersionId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete package version for a user (asynchronously)
     * Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;delete:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to delete. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#delete-a-package-version-for-a-user">Delete package version for a user Documentation</a>
     */
    public okhttp3.Call packagesDeletePackageVersionForUserAsync(String packageType, String packageName, String username, Integer packageVersionId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesDeletePackageVersionForUserValidateBeforeCall(packageType, packageName, username, packageVersionId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param state The state of the package, either active or deleted. (optional, default to active)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-the-authenticated-user">List package versions for a package owned by the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserCall(String packageType, String packageName, Integer page, Integer perPage, String state, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/packages/{package_type}/{package_name}/versions"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (state != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("state", state));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserValidateBeforeCall(String packageType, String packageName, Integer page, Integer perPage, String state, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(Async)");
        }

        return packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserCall(packageType, packageName, page, perPage, state, _callback);

    }

    /**
     * List package versions for a package owned by the authenticated user
     * Lists package versions for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param state The state of the package, either active or deleted. (optional, default to active)
     * @return List&lt;PackageVersion&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-the-authenticated-user">List package versions for a package owned by the authenticated user Documentation</a>
     */
    public List<PackageVersion> packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(String packageType, String packageName, Integer page, Integer perPage, String state) throws ApiException {
        ApiResponse<List<PackageVersion>> localVarResp = packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserWithHttpInfo(packageType, packageName, page, perPage, state);
        return localVarResp.getData();
    }

    /**
     * List package versions for a package owned by the authenticated user
     * Lists package versions for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param state The state of the package, either active or deleted. (optional, default to active)
     * @return ApiResponse&lt;List&lt;PackageVersion&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-the-authenticated-user">List package versions for a package owned by the authenticated user Documentation</a>
     */
    public ApiResponse<List<PackageVersion>> packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserWithHttpInfo(String packageType, String packageName, Integer page, Integer perPage, String state) throws ApiException {
        okhttp3.Call localVarCall = packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserValidateBeforeCall(packageType, packageName, page, perPage, state, null);
        Type localVarReturnType = new TypeToken<List<PackageVersion>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List package versions for a package owned by the authenticated user (asynchronously)
     * Lists package versions for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param state The state of the package, either active or deleted. (optional, default to active)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-the-authenticated-user">List package versions for a package owned by the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserAsync(String packageType, String packageName, Integer page, Integer perPage, String state, final ApiCallback<List<PackageVersion>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserValidateBeforeCall(packageType, packageName, page, perPage, state, _callback);
        Type localVarReturnType = new TypeToken<List<PackageVersion>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetAllPackageVersionsForPackageOwnedByOrg
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param state The state of the package, either active or deleted. (optional, default to active)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-an-organization">List package versions for a package owned by an organization Documentation</a>
     */
    public okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByOrgCall(String packageType, String packageName, String org, Integer page, Integer perPage, String state, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/packages/{package_type}/{package_name}/versions"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (state != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("state", state));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByOrgValidateBeforeCall(String packageType, String packageName, String org, Integer page, Integer perPage, String state, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetAllPackageVersionsForPackageOwnedByOrg(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetAllPackageVersionsForPackageOwnedByOrg(Async)");
        }

        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesGetAllPackageVersionsForPackageOwnedByOrg(Async)");
        }

        return packagesGetAllPackageVersionsForPackageOwnedByOrgCall(packageType, packageName, org, page, perPage, state, _callback);

    }

    /**
     * List package versions for a package owned by an organization
     * Lists package versions for a package owned by an organization.  If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param state The state of the package, either active or deleted. (optional, default to active)
     * @return List&lt;PackageVersion&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-an-organization">List package versions for a package owned by an organization Documentation</a>
     */
    public List<PackageVersion> packagesGetAllPackageVersionsForPackageOwnedByOrg(String packageType, String packageName, String org, Integer page, Integer perPage, String state) throws ApiException {
        ApiResponse<List<PackageVersion>> localVarResp = packagesGetAllPackageVersionsForPackageOwnedByOrgWithHttpInfo(packageType, packageName, org, page, perPage, state);
        return localVarResp.getData();
    }

    /**
     * List package versions for a package owned by an organization
     * Lists package versions for a package owned by an organization.  If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param state The state of the package, either active or deleted. (optional, default to active)
     * @return ApiResponse&lt;List&lt;PackageVersion&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-an-organization">List package versions for a package owned by an organization Documentation</a>
     */
    public ApiResponse<List<PackageVersion>> packagesGetAllPackageVersionsForPackageOwnedByOrgWithHttpInfo(String packageType, String packageName, String org, Integer page, Integer perPage, String state) throws ApiException {
        okhttp3.Call localVarCall = packagesGetAllPackageVersionsForPackageOwnedByOrgValidateBeforeCall(packageType, packageName, org, page, perPage, state, null);
        Type localVarReturnType = new TypeToken<List<PackageVersion>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List package versions for a package owned by an organization (asynchronously)
     * Lists package versions for a package owned by an organization.  If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param state The state of the package, either active or deleted. (optional, default to active)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-an-organization">List package versions for a package owned by an organization Documentation</a>
     */
    public okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByOrgAsync(String packageType, String packageName, String org, Integer page, Integer perPage, String state, final ApiCallback<List<PackageVersion>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetAllPackageVersionsForPackageOwnedByOrgValidateBeforeCall(packageType, packageName, org, page, perPage, state, _callback);
        Type localVarReturnType = new TypeToken<List<PackageVersion>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetAllPackageVersionsForPackageOwnedByUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-a-user">List package versions for a package owned by a user Documentation</a>
     */
    public okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByUserCall(String packageType, String packageName, String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/packages/{package_type}/{package_name}/versions"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByUserValidateBeforeCall(String packageType, String packageName, String username, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetAllPackageVersionsForPackageOwnedByUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetAllPackageVersionsForPackageOwnedByUser(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesGetAllPackageVersionsForPackageOwnedByUser(Async)");
        }

        return packagesGetAllPackageVersionsForPackageOwnedByUserCall(packageType, packageName, username, _callback);

    }

    /**
     * List package versions for a package owned by a user
     * Lists package versions for a public package owned by a specified user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @return List&lt;PackageVersion&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-a-user">List package versions for a package owned by a user Documentation</a>
     */
    public List<PackageVersion> packagesGetAllPackageVersionsForPackageOwnedByUser(String packageType, String packageName, String username) throws ApiException {
        ApiResponse<List<PackageVersion>> localVarResp = packagesGetAllPackageVersionsForPackageOwnedByUserWithHttpInfo(packageType, packageName, username);
        return localVarResp.getData();
    }

    /**
     * List package versions for a package owned by a user
     * Lists package versions for a public package owned by a specified user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @return ApiResponse&lt;List&lt;PackageVersion&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-a-user">List package versions for a package owned by a user Documentation</a>
     */
    public ApiResponse<List<PackageVersion>> packagesGetAllPackageVersionsForPackageOwnedByUserWithHttpInfo(String packageType, String packageName, String username) throws ApiException {
        okhttp3.Call localVarCall = packagesGetAllPackageVersionsForPackageOwnedByUserValidateBeforeCall(packageType, packageName, username, null);
        Type localVarReturnType = new TypeToken<List<PackageVersion>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List package versions for a package owned by a user (asynchronously)
     * Lists package versions for a public package owned by a specified user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#get-all-package-versions-for-a-package-owned-by-a-user">List package versions for a package owned by a user Documentation</a>
     */
    public okhttp3.Call packagesGetAllPackageVersionsForPackageOwnedByUserAsync(String packageType, String packageName, String username, final ApiCallback<List<PackageVersion>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetAllPackageVersionsForPackageOwnedByUserValidateBeforeCall(packageType, packageName, username, _callback);
        Type localVarReturnType = new TypeToken<List<PackageVersion>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetPackageForAuthenticatedUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-the-authenticated-user">Get a package for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesGetPackageForAuthenticatedUserCall(String packageType, String packageName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/packages/{package_type}/{package_name}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetPackageForAuthenticatedUserValidateBeforeCall(String packageType, String packageName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetPackageForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetPackageForAuthenticatedUser(Async)");
        }

        return packagesGetPackageForAuthenticatedUserCall(packageType, packageName, _callback);

    }

    /**
     * Get a package for the authenticated user
     * Gets a specific package for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @return ModelPackage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-the-authenticated-user">Get a package for the authenticated user Documentation</a>
     */
    public ModelPackage packagesGetPackageForAuthenticatedUser(String packageType, String packageName) throws ApiException {
        ApiResponse<ModelPackage> localVarResp = packagesGetPackageForAuthenticatedUserWithHttpInfo(packageType, packageName);
        return localVarResp.getData();
    }

    /**
     * Get a package for the authenticated user
     * Gets a specific package for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @return ApiResponse&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-the-authenticated-user">Get a package for the authenticated user Documentation</a>
     */
    public ApiResponse<ModelPackage> packagesGetPackageForAuthenticatedUserWithHttpInfo(String packageType, String packageName) throws ApiException {
        okhttp3.Call localVarCall = packagesGetPackageForAuthenticatedUserValidateBeforeCall(packageType, packageName, null);
        Type localVarReturnType = new TypeToken<ModelPackage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a package for the authenticated user (asynchronously)
     * Gets a specific package for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-the-authenticated-user">Get a package for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesGetPackageForAuthenticatedUserAsync(String packageType, String packageName, final ApiCallback<ModelPackage> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetPackageForAuthenticatedUserValidateBeforeCall(packageType, packageName, _callback);
        Type localVarReturnType = new TypeToken<ModelPackage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetPackageForOrganization
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-an-organization">Get a package for an organization Documentation</a>
     */
    public okhttp3.Call packagesGetPackageForOrganizationCall(String packageType, String packageName, String org, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/packages/{package_type}/{package_name}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetPackageForOrganizationValidateBeforeCall(String packageType, String packageName, String org, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetPackageForOrganization(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetPackageForOrganization(Async)");
        }

        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesGetPackageForOrganization(Async)");
        }

        return packagesGetPackageForOrganizationCall(packageType, packageName, org, _callback);

    }

    /**
     * Get a package for an organization
     * Gets a specific package in an organization.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @return ModelPackage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-an-organization">Get a package for an organization Documentation</a>
     */
    public ModelPackage packagesGetPackageForOrganization(String packageType, String packageName, String org) throws ApiException {
        ApiResponse<ModelPackage> localVarResp = packagesGetPackageForOrganizationWithHttpInfo(packageType, packageName, org);
        return localVarResp.getData();
    }

    /**
     * Get a package for an organization
     * Gets a specific package in an organization.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @return ApiResponse&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-an-organization">Get a package for an organization Documentation</a>
     */
    public ApiResponse<ModelPackage> packagesGetPackageForOrganizationWithHttpInfo(String packageType, String packageName, String org) throws ApiException {
        okhttp3.Call localVarCall = packagesGetPackageForOrganizationValidateBeforeCall(packageType, packageName, org, null);
        Type localVarReturnType = new TypeToken<ModelPackage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a package for an organization (asynchronously)
     * Gets a specific package in an organization.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-an-organization">Get a package for an organization Documentation</a>
     */
    public okhttp3.Call packagesGetPackageForOrganizationAsync(String packageType, String packageName, String org, final ApiCallback<ModelPackage> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetPackageForOrganizationValidateBeforeCall(packageType, packageName, org, _callback);
        Type localVarReturnType = new TypeToken<ModelPackage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetPackageForUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-a-user">Get a package for a user Documentation</a>
     */
    public okhttp3.Call packagesGetPackageForUserCall(String packageType, String packageName, String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/packages/{package_type}/{package_name}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetPackageForUserValidateBeforeCall(String packageType, String packageName, String username, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetPackageForUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetPackageForUser(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesGetPackageForUser(Async)");
        }

        return packagesGetPackageForUserCall(packageType, packageName, username, _callback);

    }

    /**
     * Get a package for a user
     * Gets a specific package metadata for a public package owned by a user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @return ModelPackage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-a-user">Get a package for a user Documentation</a>
     */
    public ModelPackage packagesGetPackageForUser(String packageType, String packageName, String username) throws ApiException {
        ApiResponse<ModelPackage> localVarResp = packagesGetPackageForUserWithHttpInfo(packageType, packageName, username);
        return localVarResp.getData();
    }

    /**
     * Get a package for a user
     * Gets a specific package metadata for a public package owned by a user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @return ApiResponse&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-a-user">Get a package for a user Documentation</a>
     */
    public ApiResponse<ModelPackage> packagesGetPackageForUserWithHttpInfo(String packageType, String packageName, String username) throws ApiException {
        okhttp3.Call localVarCall = packagesGetPackageForUserValidateBeforeCall(packageType, packageName, username, null);
        Type localVarReturnType = new TypeToken<ModelPackage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a package for a user (asynchronously)
     * Gets a specific package metadata for a public package owned by a user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-for-a-user">Get a package for a user Documentation</a>
     */
    public okhttp3.Call packagesGetPackageForUserAsync(String packageType, String packageName, String username, final ApiCallback<ModelPackage> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetPackageForUserValidateBeforeCall(packageType, packageName, username, _callback);
        Type localVarReturnType = new TypeToken<ModelPackage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetPackageVersionForAuthenticatedUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-the-authenticated-user">Get a package version for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesGetPackageVersionForAuthenticatedUserCall(String packageType, String packageName, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetPackageVersionForAuthenticatedUserValidateBeforeCall(String packageType, String packageName, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetPackageVersionForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetPackageVersionForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesGetPackageVersionForAuthenticatedUser(Async)");
        }

        return packagesGetPackageVersionForAuthenticatedUserCall(packageType, packageName, packageVersionId, _callback);

    }

    /**
     * Get a package version for the authenticated user
     * Gets a specific package version for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return PackageVersion
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-the-authenticated-user">Get a package version for the authenticated user Documentation</a>
     */
    public PackageVersion packagesGetPackageVersionForAuthenticatedUser(String packageType, String packageName, Integer packageVersionId) throws ApiException {
        ApiResponse<PackageVersion> localVarResp = packagesGetPackageVersionForAuthenticatedUserWithHttpInfo(packageType, packageName, packageVersionId);
        return localVarResp.getData();
    }

    /**
     * Get a package version for the authenticated user
     * Gets a specific package version for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return ApiResponse&lt;PackageVersion&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-the-authenticated-user">Get a package version for the authenticated user Documentation</a>
     */
    public ApiResponse<PackageVersion> packagesGetPackageVersionForAuthenticatedUserWithHttpInfo(String packageType, String packageName, Integer packageVersionId) throws ApiException {
        okhttp3.Call localVarCall = packagesGetPackageVersionForAuthenticatedUserValidateBeforeCall(packageType, packageName, packageVersionId, null);
        Type localVarReturnType = new TypeToken<PackageVersion>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a package version for the authenticated user (asynchronously)
     * Gets a specific package version for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-the-authenticated-user">Get a package version for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesGetPackageVersionForAuthenticatedUserAsync(String packageType, String packageName, Integer packageVersionId, final ApiCallback<PackageVersion> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetPackageVersionForAuthenticatedUserValidateBeforeCall(packageType, packageName, packageVersionId, _callback);
        Type localVarReturnType = new TypeToken<PackageVersion>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetPackageVersionForOrganization
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-an-organization">Get a package version for an organization Documentation</a>
     */
    public okhttp3.Call packagesGetPackageVersionForOrganizationCall(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetPackageVersionForOrganizationValidateBeforeCall(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetPackageVersionForOrganization(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetPackageVersionForOrganization(Async)");
        }

        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesGetPackageVersionForOrganization(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesGetPackageVersionForOrganization(Async)");
        }

        return packagesGetPackageVersionForOrganizationCall(packageType, packageName, org, packageVersionId, _callback);

    }

    /**
     * Get a package version for an organization
     * Gets a specific package version in an organization.  You must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return PackageVersion
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-an-organization">Get a package version for an organization Documentation</a>
     */
    public PackageVersion packagesGetPackageVersionForOrganization(String packageType, String packageName, String org, Integer packageVersionId) throws ApiException {
        ApiResponse<PackageVersion> localVarResp = packagesGetPackageVersionForOrganizationWithHttpInfo(packageType, packageName, org, packageVersionId);
        return localVarResp.getData();
    }

    /**
     * Get a package version for an organization
     * Gets a specific package version in an organization.  You must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return ApiResponse&lt;PackageVersion&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-an-organization">Get a package version for an organization Documentation</a>
     */
    public ApiResponse<PackageVersion> packagesGetPackageVersionForOrganizationWithHttpInfo(String packageType, String packageName, String org, Integer packageVersionId) throws ApiException {
        okhttp3.Call localVarCall = packagesGetPackageVersionForOrganizationValidateBeforeCall(packageType, packageName, org, packageVersionId, null);
        Type localVarReturnType = new TypeToken<PackageVersion>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a package version for an organization (asynchronously)
     * Gets a specific package version in an organization.  You must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-an-organization">Get a package version for an organization Documentation</a>
     */
    public okhttp3.Call packagesGetPackageVersionForOrganizationAsync(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback<PackageVersion> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetPackageVersionForOrganizationValidateBeforeCall(packageType, packageName, org, packageVersionId, _callback);
        Type localVarReturnType = new TypeToken<PackageVersion>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesGetPackageVersionForUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-a-user">Get a package version for a user Documentation</a>
     */
    public okhttp3.Call packagesGetPackageVersionForUserCall(String packageType, String packageName, Integer packageVersionId, String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()))
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesGetPackageVersionForUserValidateBeforeCall(String packageType, String packageName, Integer packageVersionId, String username, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesGetPackageVersionForUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesGetPackageVersionForUser(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesGetPackageVersionForUser(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesGetPackageVersionForUser(Async)");
        }

        return packagesGetPackageVersionForUserCall(packageType, packageName, packageVersionId, username, _callback);

    }

    /**
     * Get a package version for a user
     * Gets a specific package version for a public package owned by a specified user.  At this time, to use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param username The handle for the GitHub user account. (required)
     * @return PackageVersion
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-a-user">Get a package version for a user Documentation</a>
     */
    public PackageVersion packagesGetPackageVersionForUser(String packageType, String packageName, Integer packageVersionId, String username) throws ApiException {
        ApiResponse<PackageVersion> localVarResp = packagesGetPackageVersionForUserWithHttpInfo(packageType, packageName, packageVersionId, username);
        return localVarResp.getData();
    }

    /**
     * Get a package version for a user
     * Gets a specific package version for a public package owned by a specified user.  At this time, to use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param username The handle for the GitHub user account. (required)
     * @return ApiResponse&lt;PackageVersion&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-a-user">Get a package version for a user Documentation</a>
     */
    public ApiResponse<PackageVersion> packagesGetPackageVersionForUserWithHttpInfo(String packageType, String packageName, Integer packageVersionId, String username) throws ApiException {
        okhttp3.Call localVarCall = packagesGetPackageVersionForUserValidateBeforeCall(packageType, packageName, packageVersionId, username, null);
        Type localVarReturnType = new TypeToken<PackageVersion>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a package version for a user (asynchronously)
     * Gets a specific package version for a public package owned by a specified user.  At this time, to use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#get-a-package-version-for-a-user">Get a package version for a user Documentation</a>
     */
    public okhttp3.Call packagesGetPackageVersionForUserAsync(String packageType, String packageName, Integer packageVersionId, String username, final ApiCallback<PackageVersion> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesGetPackageVersionForUserValidateBeforeCall(packageType, packageName, packageVersionId, username, _callback);
        Type localVarReturnType = new TypeToken<PackageVersion>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesListDockerMigrationConflictingPackagesForAuthenticatedUser
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#list-docker-migration-conflicting-packages-for-authenticated-user">Get list of conflicting packages during Docker migration for authenticated-user Documentation</a>
     */
    public okhttp3.Call packagesListDockerMigrationConflictingPackagesForAuthenticatedUserCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/docker/conflicts";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesListDockerMigrationConflictingPackagesForAuthenticatedUserValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return packagesListDockerMigrationConflictingPackagesForAuthenticatedUserCall(_callback);

    }

    /**
     * Get list of conflicting packages during Docker migration for authenticated-user
     * Lists all packages that are owned by the authenticated user within the user&#39;s namespace, and that encountered a conflict during a Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @return List&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#list-docker-migration-conflicting-packages-for-authenticated-user">Get list of conflicting packages during Docker migration for authenticated-user Documentation</a>
     */
    public List<ModelPackage> packagesListDockerMigrationConflictingPackagesForAuthenticatedUser() throws ApiException {
        ApiResponse<List<ModelPackage>> localVarResp = packagesListDockerMigrationConflictingPackagesForAuthenticatedUserWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Get list of conflicting packages during Docker migration for authenticated-user
     * Lists all packages that are owned by the authenticated user within the user&#39;s namespace, and that encountered a conflict during a Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @return ApiResponse&lt;List&lt;ModelPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#list-docker-migration-conflicting-packages-for-authenticated-user">Get list of conflicting packages during Docker migration for authenticated-user Documentation</a>
     */
    public ApiResponse<List<ModelPackage>> packagesListDockerMigrationConflictingPackagesForAuthenticatedUserWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = packagesListDockerMigrationConflictingPackagesForAuthenticatedUserValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get list of conflicting packages during Docker migration for authenticated-user (asynchronously)
     * Lists all packages that are owned by the authenticated user within the user&#39;s namespace, and that encountered a conflict during a Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/packages#list-docker-migration-conflicting-packages-for-authenticated-user">Get list of conflicting packages during Docker migration for authenticated-user Documentation</a>
     */
    public okhttp3.Call packagesListDockerMigrationConflictingPackagesForAuthenticatedUserAsync(final ApiCallback<List<ModelPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesListDockerMigrationConflictingPackagesForAuthenticatedUserValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesListDockerMigrationConflictingPackagesForOrganization
     * @param org The organization name. The name is not case sensitive. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-docker-migration-conflicting-packages-for-organization">Get list of conflicting packages during Docker migration for organization Documentation</a>
     */
    public okhttp3.Call packagesListDockerMigrationConflictingPackagesForOrganizationCall(String org, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/docker/conflicts"
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesListDockerMigrationConflictingPackagesForOrganizationValidateBeforeCall(String org, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesListDockerMigrationConflictingPackagesForOrganization(Async)");
        }

        return packagesListDockerMigrationConflictingPackagesForOrganizationCall(org, _callback);

    }

    /**
     * Get list of conflicting packages during Docker migration for organization
     * Lists all packages that are in a specific organization, are readable by the requesting user, and that encountered a conflict during a Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @param org The organization name. The name is not case sensitive. (required)
     * @return List&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-docker-migration-conflicting-packages-for-organization">Get list of conflicting packages during Docker migration for organization Documentation</a>
     */
    public List<ModelPackage> packagesListDockerMigrationConflictingPackagesForOrganization(String org) throws ApiException {
        ApiResponse<List<ModelPackage>> localVarResp = packagesListDockerMigrationConflictingPackagesForOrganizationWithHttpInfo(org);
        return localVarResp.getData();
    }

    /**
     * Get list of conflicting packages during Docker migration for organization
     * Lists all packages that are in a specific organization, are readable by the requesting user, and that encountered a conflict during a Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @param org The organization name. The name is not case sensitive. (required)
     * @return ApiResponse&lt;List&lt;ModelPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-docker-migration-conflicting-packages-for-organization">Get list of conflicting packages during Docker migration for organization Documentation</a>
     */
    public ApiResponse<List<ModelPackage>> packagesListDockerMigrationConflictingPackagesForOrganizationWithHttpInfo(String org) throws ApiException {
        okhttp3.Call localVarCall = packagesListDockerMigrationConflictingPackagesForOrganizationValidateBeforeCall(org, null);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get list of conflicting packages during Docker migration for organization (asynchronously)
     * Lists all packages that are in a specific organization, are readable by the requesting user, and that encountered a conflict during a Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @param org The organization name. The name is not case sensitive. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-docker-migration-conflicting-packages-for-organization">Get list of conflicting packages during Docker migration for organization Documentation</a>
     */
    public okhttp3.Call packagesListDockerMigrationConflictingPackagesForOrganizationAsync(String org, final ApiCallback<List<ModelPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesListDockerMigrationConflictingPackagesForOrganizationValidateBeforeCall(org, _callback);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesListDockerMigrationConflictingPackagesForUser
     * @param username The handle for the GitHub user account. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-docker-migration-conflicting-packages-for-user">Get list of conflicting packages during Docker migration for user Documentation</a>
     */
    public okhttp3.Call packagesListDockerMigrationConflictingPackagesForUserCall(String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/docker/conflicts"
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesListDockerMigrationConflictingPackagesForUserValidateBeforeCall(String username, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesListDockerMigrationConflictingPackagesForUser(Async)");
        }

        return packagesListDockerMigrationConflictingPackagesForUserCall(username, _callback);

    }

    /**
     * Get list of conflicting packages during Docker migration for user
     * Lists all packages that are in a specific user&#39;s namespace, that the requesting user has access to, and that encountered a conflict during Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @param username The handle for the GitHub user account. (required)
     * @return List&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-docker-migration-conflicting-packages-for-user">Get list of conflicting packages during Docker migration for user Documentation</a>
     */
    public List<ModelPackage> packagesListDockerMigrationConflictingPackagesForUser(String username) throws ApiException {
        ApiResponse<List<ModelPackage>> localVarResp = packagesListDockerMigrationConflictingPackagesForUserWithHttpInfo(username);
        return localVarResp.getData();
    }

    /**
     * Get list of conflicting packages during Docker migration for user
     * Lists all packages that are in a specific user&#39;s namespace, that the requesting user has access to, and that encountered a conflict during Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @param username The handle for the GitHub user account. (required)
     * @return ApiResponse&lt;List&lt;ModelPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-docker-migration-conflicting-packages-for-user">Get list of conflicting packages during Docker migration for user Documentation</a>
     */
    public ApiResponse<List<ModelPackage>> packagesListDockerMigrationConflictingPackagesForUserWithHttpInfo(String username) throws ApiException {
        okhttp3.Call localVarCall = packagesListDockerMigrationConflictingPackagesForUserValidateBeforeCall(username, null);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get list of conflicting packages during Docker migration for user (asynchronously)
     * Lists all packages that are in a specific user&#39;s namespace, that the requesting user has access to, and that encountered a conflict during Docker migration. To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope.
     * @param username The handle for the GitHub user account. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-docker-migration-conflicting-packages-for-user">Get list of conflicting packages during Docker migration for user Documentation</a>
     */
    public okhttp3.Call packagesListDockerMigrationConflictingPackagesForUserAsync(String username, final ApiCallback<List<ModelPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesListDockerMigrationConflictingPackagesForUserValidateBeforeCall(username, _callback);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesListPackagesForAuthenticatedUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-the-authenticated-user">List packages for the authenticated user&#39;s namespace Documentation</a>
     */
    public okhttp3.Call packagesListPackagesForAuthenticatedUserCall(String packageType, String visibility, Integer page, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/packages";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (packageType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("package_type", packageType));
        }

        if (visibility != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibility", visibility));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesListPackagesForAuthenticatedUserValidateBeforeCall(String packageType, String visibility, Integer page, Integer perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesListPackagesForAuthenticatedUser(Async)");
        }

        return packagesListPackagesForAuthenticatedUserCall(packageType, visibility, page, perPage, _callback);

    }

    /**
     * List packages for the authenticated user&#39;s namespace
     * Lists packages owned by the authenticated user within the user&#39;s namespace.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @return List&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-the-authenticated-user">List packages for the authenticated user&#39;s namespace Documentation</a>
     */
    public List<ModelPackage> packagesListPackagesForAuthenticatedUser(String packageType, String visibility, Integer page, Integer perPage) throws ApiException {
        ApiResponse<List<ModelPackage>> localVarResp = packagesListPackagesForAuthenticatedUserWithHttpInfo(packageType, visibility, page, perPage);
        return localVarResp.getData();
    }

    /**
     * List packages for the authenticated user&#39;s namespace
     * Lists packages owned by the authenticated user within the user&#39;s namespace.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @return ApiResponse&lt;List&lt;ModelPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-the-authenticated-user">List packages for the authenticated user&#39;s namespace Documentation</a>
     */
    public ApiResponse<List<ModelPackage>> packagesListPackagesForAuthenticatedUserWithHttpInfo(String packageType, String visibility, Integer page, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = packagesListPackagesForAuthenticatedUserValidateBeforeCall(packageType, visibility, page, perPage, null);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List packages for the authenticated user&#39;s namespace (asynchronously)
     * Lists packages owned by the authenticated user within the user&#39;s namespace.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-the-authenticated-user">List packages for the authenticated user&#39;s namespace Documentation</a>
     */
    public okhttp3.Call packagesListPackagesForAuthenticatedUserAsync(String packageType, String visibility, Integer page, Integer perPage, final ApiCallback<List<ModelPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesListPackagesForAuthenticatedUserValidateBeforeCall(packageType, visibility, page, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesListPackagesForOrganization
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-an-organization">List packages for an organization Documentation</a>
     */
    public okhttp3.Call packagesListPackagesForOrganizationCall(String packageType, String org, String visibility, Integer page, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/packages"
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (packageType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("package_type", packageType));
        }

        if (visibility != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibility", visibility));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesListPackagesForOrganizationValidateBeforeCall(String packageType, String org, String visibility, Integer page, Integer perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesListPackagesForOrganization(Async)");
        }

        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesListPackagesForOrganization(Async)");
        }

        return packagesListPackagesForOrganizationCall(packageType, org, visibility, page, perPage, _callback);

    }

    /**
     * List packages for an organization
     * Lists packages in an organization readable by the user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @return List&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-an-organization">List packages for an organization Documentation</a>
     */
    public List<ModelPackage> packagesListPackagesForOrganization(String packageType, String org, String visibility, Integer page, Integer perPage) throws ApiException {
        ApiResponse<List<ModelPackage>> localVarResp = packagesListPackagesForOrganizationWithHttpInfo(packageType, org, visibility, page, perPage);
        return localVarResp.getData();
    }

    /**
     * List packages for an organization
     * Lists packages in an organization readable by the user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @return ApiResponse&lt;List&lt;ModelPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-an-organization">List packages for an organization Documentation</a>
     */
    public ApiResponse<List<ModelPackage>> packagesListPackagesForOrganizationWithHttpInfo(String packageType, String org, String visibility, Integer page, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = packagesListPackagesForOrganizationValidateBeforeCall(packageType, org, visibility, page, perPage, null);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List packages for an organization (asynchronously)
     * Lists packages in an organization readable by the user.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-an-organization">List packages for an organization Documentation</a>
     */
    public okhttp3.Call packagesListPackagesForOrganizationAsync(String packageType, String org, String visibility, Integer page, Integer perPage, final ApiCallback<List<ModelPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesListPackagesForOrganizationValidateBeforeCall(packageType, org, visibility, page, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesListPackagesForUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-user">List packages for a user Documentation</a>
     */
    public okhttp3.Call packagesListPackagesForUserCall(String packageType, String username, String visibility, Integer page, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/packages"
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (packageType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("package_type", packageType));
        }

        if (visibility != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibility", visibility));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesListPackagesForUserValidateBeforeCall(String packageType, String username, String visibility, Integer page, Integer perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesListPackagesForUser(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesListPackagesForUser(Async)");
        }

        return packagesListPackagesForUserCall(packageType, username, visibility, page, perPage, _callback);

    }

    /**
     * List packages for a user
     * Lists all packages in a user&#39;s namespace for which the requesting user has access.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @return List&lt;ModelPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-user">List packages for a user Documentation</a>
     */
    public List<ModelPackage> packagesListPackagesForUser(String packageType, String username, String visibility, Integer page, Integer perPage) throws ApiException {
        ApiResponse<List<ModelPackage>> localVarResp = packagesListPackagesForUserWithHttpInfo(packageType, username, visibility, page, perPage);
        return localVarResp.getData();
    }

    /**
     * List packages for a user
     * Lists all packages in a user&#39;s namespace for which the requesting user has access.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @return ApiResponse&lt;List&lt;ModelPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-user">List packages for a user Documentation</a>
     */
    public ApiResponse<List<ModelPackage>> packagesListPackagesForUserWithHttpInfo(String packageType, String username, String visibility, Integer page, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = packagesListPackagesForUserValidateBeforeCall(packageType, username, visibility, page, perPage, null);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List packages for a user (asynchronously)
     * Lists all packages in a user&#39;s namespace for which the requesting user has access.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; scope. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param visibility The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The &#x60;internal&#x60; visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. For the list of GitHub Packages registries that support granular permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot; (optional)
     * @param page Page number of the results to fetch. (optional, default to 1)
     * @param perPage The number of results per page (max 100). (optional, default to 30)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The value of &#x60;per_page&#x60; multiplied by &#x60;page&#x60; cannot be greater than 10000. </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#list-packages-for-user">List packages for a user Documentation</a>
     */
    public okhttp3.Call packagesListPackagesForUserAsync(String packageType, String username, String visibility, Integer page, Integer perPage, final ApiCallback<List<ModelPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesListPackagesForUserValidateBeforeCall(packageType, username, visibility, page, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<ModelPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesRestorePackageForAuthenticatedUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param token package token (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-the-authenticated-user">Restore a package for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageForAuthenticatedUserCall(String packageType, String packageName, String token, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/packages/{package_type}/{package_name}/restore"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesRestorePackageForAuthenticatedUserValidateBeforeCall(String packageType, String packageName, String token, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesRestorePackageForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesRestorePackageForAuthenticatedUser(Async)");
        }

        return packagesRestorePackageForAuthenticatedUserCall(packageType, packageName, token, _callback);

    }

    /**
     * Restore a package for the authenticated user
     * Restores a package owned by the authenticated user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param token package token (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-the-authenticated-user">Restore a package for the authenticated user Documentation</a>
     */
    public void packagesRestorePackageForAuthenticatedUser(String packageType, String packageName, String token) throws ApiException {
        packagesRestorePackageForAuthenticatedUserWithHttpInfo(packageType, packageName, token);
    }

    /**
     * Restore a package for the authenticated user
     * Restores a package owned by the authenticated user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param token package token (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-the-authenticated-user">Restore a package for the authenticated user Documentation</a>
     */
    public ApiResponse<Void> packagesRestorePackageForAuthenticatedUserWithHttpInfo(String packageType, String packageName, String token) throws ApiException {
        okhttp3.Call localVarCall = packagesRestorePackageForAuthenticatedUserValidateBeforeCall(packageType, packageName, token, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Restore a package for the authenticated user (asynchronously)
     * Restores a package owned by the authenticated user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param token package token (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-the-authenticated-user">Restore a package for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageForAuthenticatedUserAsync(String packageType, String packageName, String token, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesRestorePackageForAuthenticatedUserValidateBeforeCall(packageType, packageName, token, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesRestorePackageForOrg
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param token package token (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-an-organization">Restore a package for an organization Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageForOrgCall(String packageType, String packageName, String org, String token, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/packages/{package_type}/{package_name}/restore"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesRestorePackageForOrgValidateBeforeCall(String packageType, String packageName, String org, String token, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesRestorePackageForOrg(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesRestorePackageForOrg(Async)");
        }

        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesRestorePackageForOrg(Async)");
        }

        return packagesRestorePackageForOrgCall(packageType, packageName, org, token, _callback);

    }

    /**
     * Restore a package for an organization
     * Restores an entire package in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param token package token (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-an-organization">Restore a package for an organization Documentation</a>
     */
    public void packagesRestorePackageForOrg(String packageType, String packageName, String org, String token) throws ApiException {
        packagesRestorePackageForOrgWithHttpInfo(packageType, packageName, org, token);
    }

    /**
     * Restore a package for an organization
     * Restores an entire package in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param token package token (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-an-organization">Restore a package for an organization Documentation</a>
     */
    public ApiResponse<Void> packagesRestorePackageForOrgWithHttpInfo(String packageType, String packageName, String org, String token) throws ApiException {
        okhttp3.Call localVarCall = packagesRestorePackageForOrgValidateBeforeCall(packageType, packageName, org, token, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Restore a package for an organization (asynchronously)
     * Restores an entire package in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param token package token (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-an-organization">Restore a package for an organization Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageForOrgAsync(String packageType, String packageName, String org, String token, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesRestorePackageForOrgValidateBeforeCall(packageType, packageName, org, token, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesRestorePackageForUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param token package token (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-a-user">Restore a package for a user Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageForUserCall(String packageType, String packageName, String username, String token, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/packages/{package_type}/{package_name}/restore"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesRestorePackageForUserValidateBeforeCall(String packageType, String packageName, String username, String token, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesRestorePackageForUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesRestorePackageForUser(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesRestorePackageForUser(Async)");
        }

        return packagesRestorePackageForUserCall(packageType, packageName, username, token, _callback);

    }

    /**
     * Restore a package for a user
     * Restores an entire package for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param token package token (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-a-user">Restore a package for a user Documentation</a>
     */
    public void packagesRestorePackageForUser(String packageType, String packageName, String username, String token) throws ApiException {
        packagesRestorePackageForUserWithHttpInfo(packageType, packageName, username, token);
    }

    /**
     * Restore a package for a user
     * Restores an entire package for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param token package token (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-a-user">Restore a package for a user Documentation</a>
     */
    public ApiResponse<Void> packagesRestorePackageForUserWithHttpInfo(String packageType, String packageName, String username, String token) throws ApiException {
        okhttp3.Call localVarCall = packagesRestorePackageForUserValidateBeforeCall(packageType, packageName, username, token, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Restore a package for a user (asynchronously)
     * Restores an entire package for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param token package token (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-for-a-user">Restore a package for a user Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageForUserAsync(String packageType, String packageName, String username, String token, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesRestorePackageForUserValidateBeforeCall(packageType, packageName, username, token, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesRestorePackageVersionForAuthenticatedUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-the-authenticated-user">Restore a package version for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageVersionForAuthenticatedUserCall(String packageType, String packageName, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesRestorePackageVersionForAuthenticatedUserValidateBeforeCall(String packageType, String packageName, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesRestorePackageVersionForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesRestorePackageVersionForAuthenticatedUser(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesRestorePackageVersionForAuthenticatedUser(Async)");
        }

        return packagesRestorePackageVersionForAuthenticatedUserCall(packageType, packageName, packageVersionId, _callback);

    }

    /**
     * Restore a package version for the authenticated user
     * Restores a package version owned by the authenticated user.  You can restore a deleted package version under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-the-authenticated-user">Restore a package version for the authenticated user Documentation</a>
     */
    public void packagesRestorePackageVersionForAuthenticatedUser(String packageType, String packageName, Integer packageVersionId) throws ApiException {
        packagesRestorePackageVersionForAuthenticatedUserWithHttpInfo(packageType, packageName, packageVersionId);
    }

    /**
     * Restore a package version for the authenticated user
     * Restores a package version owned by the authenticated user.  You can restore a deleted package version under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-the-authenticated-user">Restore a package version for the authenticated user Documentation</a>
     */
    public ApiResponse<Void> packagesRestorePackageVersionForAuthenticatedUserWithHttpInfo(String packageType, String packageName, Integer packageVersionId) throws ApiException {
        okhttp3.Call localVarCall = packagesRestorePackageVersionForAuthenticatedUserValidateBeforeCall(packageType, packageName, packageVersionId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Restore a package version for the authenticated user (asynchronously)
     * Restores a package version owned by the authenticated user.  You can restore a deleted package version under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-the-authenticated-user">Restore a package version for the authenticated user Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageVersionForAuthenticatedUserAsync(String packageType, String packageName, Integer packageVersionId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesRestorePackageVersionForAuthenticatedUserValidateBeforeCall(packageType, packageName, packageVersionId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesRestorePackageVersionForOrg
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-an-organization">Restore package version for an organization Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageVersionForOrgCall(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "org" + "}", localVarApiClient.escapeString(org.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesRestorePackageVersionForOrgValidateBeforeCall(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesRestorePackageVersionForOrg(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesRestorePackageVersionForOrg(Async)");
        }

        // verify the required parameter 'org' is set
        if (org == null) {
            throw new ApiException("Missing the required parameter 'org' when calling packagesRestorePackageVersionForOrg(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesRestorePackageVersionForOrg(Async)");
        }

        return packagesRestorePackageVersionForOrgCall(packageType, packageName, org, packageVersionId, _callback);

    }

    /**
     * Restore package version for an organization
     * Restores a specific package version in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-an-organization">Restore package version for an organization Documentation</a>
     */
    public void packagesRestorePackageVersionForOrg(String packageType, String packageName, String org, Integer packageVersionId) throws ApiException {
        packagesRestorePackageVersionForOrgWithHttpInfo(packageType, packageName, org, packageVersionId);
    }

    /**
     * Restore package version for an organization
     * Restores a specific package version in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-an-organization">Restore package version for an organization Documentation</a>
     */
    public ApiResponse<Void> packagesRestorePackageVersionForOrgWithHttpInfo(String packageType, String packageName, String org, Integer packageVersionId) throws ApiException {
        okhttp3.Call localVarCall = packagesRestorePackageVersionForOrgValidateBeforeCall(packageType, packageName, org, packageVersionId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Restore package version for an organization (asynchronously)
     * Restores a specific package version in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param org The organization name. The name is not case sensitive. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-an-organization">Restore package version for an organization Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageVersionForOrgAsync(String packageType, String packageName, String org, Integer packageVersionId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesRestorePackageVersionForOrgValidateBeforeCall(packageType, packageName, org, packageVersionId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for packagesRestorePackageVersionForUser
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-a-user">Restore package version for a user Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageVersionForUserCall(String packageType, String packageName, String username, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
            .replace("{" + "package_type" + "}", localVarApiClient.escapeString(packageType.toString()))
            .replace("{" + "package_name" + "}", localVarApiClient.escapeString(packageName.toString()))
            .replace("{" + "username" + "}", localVarApiClient.escapeString(username.toString()))
            .replace("{" + "package_version_id" + "}", localVarApiClient.escapeString(packageVersionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call packagesRestorePackageVersionForUserValidateBeforeCall(String packageType, String packageName, String username, Integer packageVersionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'packageType' is set
        if (packageType == null) {
            throw new ApiException("Missing the required parameter 'packageType' when calling packagesRestorePackageVersionForUser(Async)");
        }

        // verify the required parameter 'packageName' is set
        if (packageName == null) {
            throw new ApiException("Missing the required parameter 'packageName' when calling packagesRestorePackageVersionForUser(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling packagesRestorePackageVersionForUser(Async)");
        }

        // verify the required parameter 'packageVersionId' is set
        if (packageVersionId == null) {
            throw new ApiException("Missing the required parameter 'packageVersionId' when calling packagesRestorePackageVersionForUser(Async)");
        }

        return packagesRestorePackageVersionForUserCall(packageType, packageName, username, packageVersionId, _callback);

    }

    /**
     * Restore package version for a user
     * Restores a specific package version for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-a-user">Restore package version for a user Documentation</a>
     */
    public void packagesRestorePackageVersionForUser(String packageType, String packageName, String username, Integer packageVersionId) throws ApiException {
        packagesRestorePackageVersionForUserWithHttpInfo(packageType, packageName, username, packageVersionId);
    }

    /**
     * Restore package version for a user
     * Restores a specific package version for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-a-user">Restore package version for a user Documentation</a>
     */
    public ApiResponse<Void> packagesRestorePackageVersionForUserWithHttpInfo(String packageType, String packageName, String username, Integer packageVersionId) throws ApiException {
        okhttp3.Call localVarCall = packagesRestorePackageVersionForUserValidateBeforeCall(packageType, packageName, username, packageVersionId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Restore package version for a user (asynchronously)
     * Restores a specific package version for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package&#39;s namespace first.  To use this endpoint, you must authenticate using an access token with the &#x60;read:packages&#x60; and &#x60;write:packages&#x60; scopes. In addition: - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the &#x60;repo&#x60; scope. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\&quot; - If the &#x60;package_type&#x60; belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to restore. For the list of these registries, see \&quot;[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\&quot;
     * @param packageType The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry. (required)
     * @param packageName The name of the package. (required)
     * @param username The handle for the GitHub user account. (required)
     * @param packageVersionId Unique identifier of the package version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requires authentication </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://docs.github.com/rest/reference/packages#restore-a-package-version-for-a-user">Restore package version for a user Documentation</a>
     */
    public okhttp3.Call packagesRestorePackageVersionForUserAsync(String packageType, String packageName, String username, Integer packageVersionId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = packagesRestorePackageVersionForUserValidateBeforeCall(packageType, packageName, username, packageVersionId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
