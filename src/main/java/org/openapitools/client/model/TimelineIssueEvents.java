/*
 * GitHub v3 REST API
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.client.model.AddedToProjectIssueEvent;
import org.openapitools.client.model.AddedToProjectIssueEventProjectCard;
import org.openapitools.client.model.AuthorAssociation;
import org.openapitools.client.model.CommitComment;
import org.openapitools.client.model.ConvertedNoteToIssueIssueEvent;
import org.openapitools.client.model.DemilestonedIssueEvent;
import org.openapitools.client.model.GitCommitAuthor;
import org.openapitools.client.model.GitCommitParentsInner;
import org.openapitools.client.model.GitCommitTree;
import org.openapitools.client.model.GitCommitVerification;
import org.openapitools.client.model.LabeledIssueEvent;
import org.openapitools.client.model.LabeledIssueEventLabel;
import org.openapitools.client.model.LockedIssueEvent;
import org.openapitools.client.model.MilestonedIssueEvent;
import org.openapitools.client.model.MilestonedIssueEventMilestone;
import org.openapitools.client.model.MovedColumnInProjectIssueEvent;
import org.openapitools.client.model.NullableIntegration;
import org.openapitools.client.model.ReactionRollup;
import org.openapitools.client.model.RemovedFromProjectIssueEvent;
import org.openapitools.client.model.RenamedIssueEvent;
import org.openapitools.client.model.RenamedIssueEventRename;
import org.openapitools.client.model.ReviewDismissedIssueEvent;
import org.openapitools.client.model.ReviewDismissedIssueEventDismissedReview;
import org.openapitools.client.model.ReviewRequestRemovedIssueEvent;
import org.openapitools.client.model.ReviewRequestedIssueEvent;
import org.openapitools.client.model.SimpleUser;
import org.openapitools.client.model.StateChangeIssueEvent;
import org.openapitools.client.model.Team;
import org.openapitools.client.model.TimelineAssignedIssueEvent;
import org.openapitools.client.model.TimelineCommentEvent;
import org.openapitools.client.model.TimelineCommitCommentedEvent;
import org.openapitools.client.model.TimelineCommittedEvent;
import org.openapitools.client.model.TimelineCrossReferencedEvent;
import org.openapitools.client.model.TimelineCrossReferencedEventSource;
import org.openapitools.client.model.TimelineLineCommentedEvent;
import org.openapitools.client.model.TimelineReviewedEvent;
import org.openapitools.client.model.TimelineReviewedEventLinks;
import org.openapitools.client.model.TimelineUnassignedIssueEvent;
import org.openapitools.client.model.UnlabeledIssueEvent;
import org.openapitools.jackson.nullable.JsonNullable;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-05-09T20:37:23.111113500+10:00[Australia/Brisbane]")
public class TimelineIssueEvents extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(TimelineIssueEvents.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!TimelineIssueEvents.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'TimelineIssueEvents' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<AddedToProjectIssueEvent> adapterAddedToProjectIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(AddedToProjectIssueEvent.class));
            final TypeAdapter<ConvertedNoteToIssueIssueEvent> adapterConvertedNoteToIssueIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(ConvertedNoteToIssueIssueEvent.class));
            final TypeAdapter<DemilestonedIssueEvent> adapterDemilestonedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(DemilestonedIssueEvent.class));
            final TypeAdapter<LabeledIssueEvent> adapterLabeledIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(LabeledIssueEvent.class));
            final TypeAdapter<LockedIssueEvent> adapterLockedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(LockedIssueEvent.class));
            final TypeAdapter<MilestonedIssueEvent> adapterMilestonedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(MilestonedIssueEvent.class));
            final TypeAdapter<MovedColumnInProjectIssueEvent> adapterMovedColumnInProjectIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(MovedColumnInProjectIssueEvent.class));
            final TypeAdapter<RemovedFromProjectIssueEvent> adapterRemovedFromProjectIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(RemovedFromProjectIssueEvent.class));
            final TypeAdapter<RenamedIssueEvent> adapterRenamedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(RenamedIssueEvent.class));
            final TypeAdapter<ReviewDismissedIssueEvent> adapterReviewDismissedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(ReviewDismissedIssueEvent.class));
            final TypeAdapter<ReviewRequestRemovedIssueEvent> adapterReviewRequestRemovedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(ReviewRequestRemovedIssueEvent.class));
            final TypeAdapter<ReviewRequestedIssueEvent> adapterReviewRequestedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(ReviewRequestedIssueEvent.class));
            final TypeAdapter<StateChangeIssueEvent> adapterStateChangeIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(StateChangeIssueEvent.class));
            final TypeAdapter<TimelineAssignedIssueEvent> adapterTimelineAssignedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(TimelineAssignedIssueEvent.class));
            final TypeAdapter<TimelineCommentEvent> adapterTimelineCommentEvent = gson.getDelegateAdapter(this, TypeToken.get(TimelineCommentEvent.class));
            final TypeAdapter<TimelineCommitCommentedEvent> adapterTimelineCommitCommentedEvent = gson.getDelegateAdapter(this, TypeToken.get(TimelineCommitCommentedEvent.class));
            final TypeAdapter<TimelineCommittedEvent> adapterTimelineCommittedEvent = gson.getDelegateAdapter(this, TypeToken.get(TimelineCommittedEvent.class));
            final TypeAdapter<TimelineCrossReferencedEvent> adapterTimelineCrossReferencedEvent = gson.getDelegateAdapter(this, TypeToken.get(TimelineCrossReferencedEvent.class));
            final TypeAdapter<TimelineLineCommentedEvent> adapterTimelineLineCommentedEvent = gson.getDelegateAdapter(this, TypeToken.get(TimelineLineCommentedEvent.class));
            final TypeAdapter<TimelineReviewedEvent> adapterTimelineReviewedEvent = gson.getDelegateAdapter(this, TypeToken.get(TimelineReviewedEvent.class));
            final TypeAdapter<TimelineUnassignedIssueEvent> adapterTimelineUnassignedIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(TimelineUnassignedIssueEvent.class));
            final TypeAdapter<UnlabeledIssueEvent> adapterUnlabeledIssueEvent = gson.getDelegateAdapter(this, TypeToken.get(UnlabeledIssueEvent.class));

            return (TypeAdapter<T>) new TypeAdapter<TimelineIssueEvents>() {
                @Override
                public void write(JsonWriter out, TimelineIssueEvents value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `AddedToProjectIssueEvent`
                    if (value.getActualInstance() instanceof AddedToProjectIssueEvent) {
                        JsonObject obj = adapterAddedToProjectIssueEvent.toJsonTree((AddedToProjectIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `ConvertedNoteToIssueIssueEvent`
                    if (value.getActualInstance() instanceof ConvertedNoteToIssueIssueEvent) {
                        JsonObject obj = adapterConvertedNoteToIssueIssueEvent.toJsonTree((ConvertedNoteToIssueIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `DemilestonedIssueEvent`
                    if (value.getActualInstance() instanceof DemilestonedIssueEvent) {
                        JsonObject obj = adapterDemilestonedIssueEvent.toJsonTree((DemilestonedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `LabeledIssueEvent`
                    if (value.getActualInstance() instanceof LabeledIssueEvent) {
                        JsonObject obj = adapterLabeledIssueEvent.toJsonTree((LabeledIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `LockedIssueEvent`
                    if (value.getActualInstance() instanceof LockedIssueEvent) {
                        JsonObject obj = adapterLockedIssueEvent.toJsonTree((LockedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `MilestonedIssueEvent`
                    if (value.getActualInstance() instanceof MilestonedIssueEvent) {
                        JsonObject obj = adapterMilestonedIssueEvent.toJsonTree((MilestonedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `MovedColumnInProjectIssueEvent`
                    if (value.getActualInstance() instanceof MovedColumnInProjectIssueEvent) {
                        JsonObject obj = adapterMovedColumnInProjectIssueEvent.toJsonTree((MovedColumnInProjectIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `RemovedFromProjectIssueEvent`
                    if (value.getActualInstance() instanceof RemovedFromProjectIssueEvent) {
                        JsonObject obj = adapterRemovedFromProjectIssueEvent.toJsonTree((RemovedFromProjectIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `RenamedIssueEvent`
                    if (value.getActualInstance() instanceof RenamedIssueEvent) {
                        JsonObject obj = adapterRenamedIssueEvent.toJsonTree((RenamedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `ReviewDismissedIssueEvent`
                    if (value.getActualInstance() instanceof ReviewDismissedIssueEvent) {
                        JsonObject obj = adapterReviewDismissedIssueEvent.toJsonTree((ReviewDismissedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `ReviewRequestRemovedIssueEvent`
                    if (value.getActualInstance() instanceof ReviewRequestRemovedIssueEvent) {
                        JsonObject obj = adapterReviewRequestRemovedIssueEvent.toJsonTree((ReviewRequestRemovedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `ReviewRequestedIssueEvent`
                    if (value.getActualInstance() instanceof ReviewRequestedIssueEvent) {
                        JsonObject obj = adapterReviewRequestedIssueEvent.toJsonTree((ReviewRequestedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `StateChangeIssueEvent`
                    if (value.getActualInstance() instanceof StateChangeIssueEvent) {
                        JsonObject obj = adapterStateChangeIssueEvent.toJsonTree((StateChangeIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `TimelineAssignedIssueEvent`
                    if (value.getActualInstance() instanceof TimelineAssignedIssueEvent) {
                        JsonObject obj = adapterTimelineAssignedIssueEvent.toJsonTree((TimelineAssignedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `TimelineCommentEvent`
                    if (value.getActualInstance() instanceof TimelineCommentEvent) {
                        JsonObject obj = adapterTimelineCommentEvent.toJsonTree((TimelineCommentEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `TimelineCommitCommentedEvent`
                    if (value.getActualInstance() instanceof TimelineCommitCommentedEvent) {
                        JsonObject obj = adapterTimelineCommitCommentedEvent.toJsonTree((TimelineCommitCommentedEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `TimelineCommittedEvent`
                    if (value.getActualInstance() instanceof TimelineCommittedEvent) {
                        JsonObject obj = adapterTimelineCommittedEvent.toJsonTree((TimelineCommittedEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `TimelineCrossReferencedEvent`
                    if (value.getActualInstance() instanceof TimelineCrossReferencedEvent) {
                        JsonObject obj = adapterTimelineCrossReferencedEvent.toJsonTree((TimelineCrossReferencedEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `TimelineLineCommentedEvent`
                    if (value.getActualInstance() instanceof TimelineLineCommentedEvent) {
                        JsonObject obj = adapterTimelineLineCommentedEvent.toJsonTree((TimelineLineCommentedEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `TimelineReviewedEvent`
                    if (value.getActualInstance() instanceof TimelineReviewedEvent) {
                        JsonObject obj = adapterTimelineReviewedEvent.toJsonTree((TimelineReviewedEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `TimelineUnassignedIssueEvent`
                    if (value.getActualInstance() instanceof TimelineUnassignedIssueEvent) {
                        JsonObject obj = adapterTimelineUnassignedIssueEvent.toJsonTree((TimelineUnassignedIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `UnlabeledIssueEvent`
                    if (value.getActualInstance() instanceof UnlabeledIssueEvent) {
                        JsonObject obj = adapterUnlabeledIssueEvent.toJsonTree((UnlabeledIssueEvent)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match anyOf schemas: AddedToProjectIssueEvent, ConvertedNoteToIssueIssueEvent, DemilestonedIssueEvent, LabeledIssueEvent, LockedIssueEvent, MilestonedIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, RenamedIssueEvent, ReviewDismissedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewRequestedIssueEvent, StateChangeIssueEvent, TimelineAssignedIssueEvent, TimelineCommentEvent, TimelineCommitCommentedEvent, TimelineCommittedEvent, TimelineCrossReferencedEvent, TimelineLineCommentedEvent, TimelineReviewedEvent, TimelineUnassignedIssueEvent, UnlabeledIssueEvent");
                }

                @Override
                public TimelineIssueEvents read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();

                    // deserialize AddedToProjectIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        AddedToProjectIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'AddedToProjectIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterAddedToProjectIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'AddedToProjectIssueEvent'", e);
                    }

                    // deserialize ConvertedNoteToIssueIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ConvertedNoteToIssueIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'ConvertedNoteToIssueIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterConvertedNoteToIssueIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'ConvertedNoteToIssueIssueEvent'", e);
                    }

                    // deserialize DemilestonedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DemilestonedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'DemilestonedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterDemilestonedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'DemilestonedIssueEvent'", e);
                    }

                    // deserialize LabeledIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        LabeledIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'LabeledIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterLabeledIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'LabeledIssueEvent'", e);
                    }

                    // deserialize LockedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        LockedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'LockedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterLockedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'LockedIssueEvent'", e);
                    }

                    // deserialize MilestonedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        MilestonedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'MilestonedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterMilestonedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'MilestonedIssueEvent'", e);
                    }

                    // deserialize MovedColumnInProjectIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        MovedColumnInProjectIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'MovedColumnInProjectIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterMovedColumnInProjectIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'MovedColumnInProjectIssueEvent'", e);
                    }

                    // deserialize RemovedFromProjectIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        RemovedFromProjectIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'RemovedFromProjectIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterRemovedFromProjectIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'RemovedFromProjectIssueEvent'", e);
                    }

                    // deserialize RenamedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        RenamedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'RenamedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterRenamedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'RenamedIssueEvent'", e);
                    }

                    // deserialize ReviewDismissedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ReviewDismissedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'ReviewDismissedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterReviewDismissedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'ReviewDismissedIssueEvent'", e);
                    }

                    // deserialize ReviewRequestRemovedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ReviewRequestRemovedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'ReviewRequestRemovedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterReviewRequestRemovedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'ReviewRequestRemovedIssueEvent'", e);
                    }

                    // deserialize ReviewRequestedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ReviewRequestedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'ReviewRequestedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterReviewRequestedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'ReviewRequestedIssueEvent'", e);
                    }

                    // deserialize StateChangeIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        StateChangeIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'StateChangeIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterStateChangeIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'StateChangeIssueEvent'", e);
                    }

                    // deserialize TimelineAssignedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TimelineAssignedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'TimelineAssignedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterTimelineAssignedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'TimelineAssignedIssueEvent'", e);
                    }

                    // deserialize TimelineCommentEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TimelineCommentEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'TimelineCommentEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterTimelineCommentEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'TimelineCommentEvent'", e);
                    }

                    // deserialize TimelineCommitCommentedEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TimelineCommitCommentedEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'TimelineCommitCommentedEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterTimelineCommitCommentedEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'TimelineCommitCommentedEvent'", e);
                    }

                    // deserialize TimelineCommittedEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TimelineCommittedEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'TimelineCommittedEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterTimelineCommittedEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'TimelineCommittedEvent'", e);
                    }

                    // deserialize TimelineCrossReferencedEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TimelineCrossReferencedEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'TimelineCrossReferencedEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterTimelineCrossReferencedEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'TimelineCrossReferencedEvent'", e);
                    }

                    // deserialize TimelineLineCommentedEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TimelineLineCommentedEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'TimelineLineCommentedEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterTimelineLineCommentedEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'TimelineLineCommentedEvent'", e);
                    }

                    // deserialize TimelineReviewedEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TimelineReviewedEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'TimelineReviewedEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterTimelineReviewedEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'TimelineReviewedEvent'", e);
                    }

                    // deserialize TimelineUnassignedIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TimelineUnassignedIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'TimelineUnassignedIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterTimelineUnassignedIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'TimelineUnassignedIssueEvent'", e);
                    }

                    // deserialize UnlabeledIssueEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        UnlabeledIssueEvent.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'UnlabeledIssueEvent'");
                        TimelineIssueEvents ret = new TimelineIssueEvents();
                        ret.setActualInstance(adapterUnlabeledIssueEvent.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'UnlabeledIssueEvent'", e);
                    }


                    throw new IOException(String.format("Failed deserialization for TimelineIssueEvents: no class matched. JSON: %s", jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public TimelineIssueEvents() {
        super("anyOf", Boolean.FALSE);
    }

    public TimelineIssueEvents(AddedToProjectIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(ConvertedNoteToIssueIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(DemilestonedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(LabeledIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(LockedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(MilestonedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(MovedColumnInProjectIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(RemovedFromProjectIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(RenamedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(ReviewDismissedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(ReviewRequestRemovedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(ReviewRequestedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(StateChangeIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(TimelineAssignedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(TimelineCommentEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(TimelineCommitCommentedEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(TimelineCommittedEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(TimelineCrossReferencedEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(TimelineLineCommentedEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(TimelineReviewedEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(TimelineUnassignedIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public TimelineIssueEvents(UnlabeledIssueEvent o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AddedToProjectIssueEvent", new GenericType<AddedToProjectIssueEvent>() {
        });
        schemas.put("ConvertedNoteToIssueIssueEvent", new GenericType<ConvertedNoteToIssueIssueEvent>() {
        });
        schemas.put("DemilestonedIssueEvent", new GenericType<DemilestonedIssueEvent>() {
        });
        schemas.put("LabeledIssueEvent", new GenericType<LabeledIssueEvent>() {
        });
        schemas.put("LockedIssueEvent", new GenericType<LockedIssueEvent>() {
        });
        schemas.put("MilestonedIssueEvent", new GenericType<MilestonedIssueEvent>() {
        });
        schemas.put("MovedColumnInProjectIssueEvent", new GenericType<MovedColumnInProjectIssueEvent>() {
        });
        schemas.put("RemovedFromProjectIssueEvent", new GenericType<RemovedFromProjectIssueEvent>() {
        });
        schemas.put("RenamedIssueEvent", new GenericType<RenamedIssueEvent>() {
        });
        schemas.put("ReviewDismissedIssueEvent", new GenericType<ReviewDismissedIssueEvent>() {
        });
        schemas.put("ReviewRequestRemovedIssueEvent", new GenericType<ReviewRequestRemovedIssueEvent>() {
        });
        schemas.put("ReviewRequestedIssueEvent", new GenericType<ReviewRequestedIssueEvent>() {
        });
        schemas.put("StateChangeIssueEvent", new GenericType<StateChangeIssueEvent>() {
        });
        schemas.put("TimelineAssignedIssueEvent", new GenericType<TimelineAssignedIssueEvent>() {
        });
        schemas.put("TimelineCommentEvent", new GenericType<TimelineCommentEvent>() {
        });
        schemas.put("TimelineCommitCommentedEvent", new GenericType<TimelineCommitCommentedEvent>() {
        });
        schemas.put("TimelineCommittedEvent", new GenericType<TimelineCommittedEvent>() {
        });
        schemas.put("TimelineCrossReferencedEvent", new GenericType<TimelineCrossReferencedEvent>() {
        });
        schemas.put("TimelineLineCommentedEvent", new GenericType<TimelineLineCommentedEvent>() {
        });
        schemas.put("TimelineReviewedEvent", new GenericType<TimelineReviewedEvent>() {
        });
        schemas.put("TimelineUnassignedIssueEvent", new GenericType<TimelineUnassignedIssueEvent>() {
        });
        schemas.put("UnlabeledIssueEvent", new GenericType<UnlabeledIssueEvent>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return TimelineIssueEvents.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * AddedToProjectIssueEvent, ConvertedNoteToIssueIssueEvent, DemilestonedIssueEvent, LabeledIssueEvent, LockedIssueEvent, MilestonedIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, RenamedIssueEvent, ReviewDismissedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewRequestedIssueEvent, StateChangeIssueEvent, TimelineAssignedIssueEvent, TimelineCommentEvent, TimelineCommitCommentedEvent, TimelineCommittedEvent, TimelineCrossReferencedEvent, TimelineLineCommentedEvent, TimelineReviewedEvent, TimelineUnassignedIssueEvent, UnlabeledIssueEvent
     *
     * It could be an instance of the 'anyOf' schemas.
     * The anyOf child schemas may themselves be a composed schema (allOf, anyOf, anyOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof AddedToProjectIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ConvertedNoteToIssueIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DemilestonedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof LabeledIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof LockedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof MilestonedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof MovedColumnInProjectIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof RemovedFromProjectIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof RenamedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ReviewDismissedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ReviewRequestRemovedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ReviewRequestedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof StateChangeIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TimelineAssignedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TimelineCommentEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TimelineCommitCommentedEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TimelineCommittedEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TimelineCrossReferencedEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TimelineLineCommentedEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TimelineReviewedEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TimelineUnassignedIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof UnlabeledIssueEvent) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AddedToProjectIssueEvent, ConvertedNoteToIssueIssueEvent, DemilestonedIssueEvent, LabeledIssueEvent, LockedIssueEvent, MilestonedIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, RenamedIssueEvent, ReviewDismissedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewRequestedIssueEvent, StateChangeIssueEvent, TimelineAssignedIssueEvent, TimelineCommentEvent, TimelineCommitCommentedEvent, TimelineCommittedEvent, TimelineCrossReferencedEvent, TimelineLineCommentedEvent, TimelineReviewedEvent, TimelineUnassignedIssueEvent, UnlabeledIssueEvent");
    }

    /**
     * Get the actual instance, which can be the following:
     * AddedToProjectIssueEvent, ConvertedNoteToIssueIssueEvent, DemilestonedIssueEvent, LabeledIssueEvent, LockedIssueEvent, MilestonedIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, RenamedIssueEvent, ReviewDismissedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewRequestedIssueEvent, StateChangeIssueEvent, TimelineAssignedIssueEvent, TimelineCommentEvent, TimelineCommitCommentedEvent, TimelineCommittedEvent, TimelineCrossReferencedEvent, TimelineLineCommentedEvent, TimelineReviewedEvent, TimelineUnassignedIssueEvent, UnlabeledIssueEvent
     *
     * @return The actual instance (AddedToProjectIssueEvent, ConvertedNoteToIssueIssueEvent, DemilestonedIssueEvent, LabeledIssueEvent, LockedIssueEvent, MilestonedIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, RenamedIssueEvent, ReviewDismissedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewRequestedIssueEvent, StateChangeIssueEvent, TimelineAssignedIssueEvent, TimelineCommentEvent, TimelineCommitCommentedEvent, TimelineCommittedEvent, TimelineCrossReferencedEvent, TimelineLineCommentedEvent, TimelineReviewedEvent, TimelineUnassignedIssueEvent, UnlabeledIssueEvent)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `AddedToProjectIssueEvent`. If the actual instance is not `AddedToProjectIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AddedToProjectIssueEvent`
     * @throws ClassCastException if the instance is not `AddedToProjectIssueEvent`
     */
    public AddedToProjectIssueEvent getAddedToProjectIssueEvent() throws ClassCastException {
        return (AddedToProjectIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ConvertedNoteToIssueIssueEvent`. If the actual instance is not `ConvertedNoteToIssueIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ConvertedNoteToIssueIssueEvent`
     * @throws ClassCastException if the instance is not `ConvertedNoteToIssueIssueEvent`
     */
    public ConvertedNoteToIssueIssueEvent getConvertedNoteToIssueIssueEvent() throws ClassCastException {
        return (ConvertedNoteToIssueIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DemilestonedIssueEvent`. If the actual instance is not `DemilestonedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DemilestonedIssueEvent`
     * @throws ClassCastException if the instance is not `DemilestonedIssueEvent`
     */
    public DemilestonedIssueEvent getDemilestonedIssueEvent() throws ClassCastException {
        return (DemilestonedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `LabeledIssueEvent`. If the actual instance is not `LabeledIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `LabeledIssueEvent`
     * @throws ClassCastException if the instance is not `LabeledIssueEvent`
     */
    public LabeledIssueEvent getLabeledIssueEvent() throws ClassCastException {
        return (LabeledIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `LockedIssueEvent`. If the actual instance is not `LockedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `LockedIssueEvent`
     * @throws ClassCastException if the instance is not `LockedIssueEvent`
     */
    public LockedIssueEvent getLockedIssueEvent() throws ClassCastException {
        return (LockedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MilestonedIssueEvent`. If the actual instance is not `MilestonedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MilestonedIssueEvent`
     * @throws ClassCastException if the instance is not `MilestonedIssueEvent`
     */
    public MilestonedIssueEvent getMilestonedIssueEvent() throws ClassCastException {
        return (MilestonedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MovedColumnInProjectIssueEvent`. If the actual instance is not `MovedColumnInProjectIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MovedColumnInProjectIssueEvent`
     * @throws ClassCastException if the instance is not `MovedColumnInProjectIssueEvent`
     */
    public MovedColumnInProjectIssueEvent getMovedColumnInProjectIssueEvent() throws ClassCastException {
        return (MovedColumnInProjectIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `RemovedFromProjectIssueEvent`. If the actual instance is not `RemovedFromProjectIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `RemovedFromProjectIssueEvent`
     * @throws ClassCastException if the instance is not `RemovedFromProjectIssueEvent`
     */
    public RemovedFromProjectIssueEvent getRemovedFromProjectIssueEvent() throws ClassCastException {
        return (RemovedFromProjectIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `RenamedIssueEvent`. If the actual instance is not `RenamedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `RenamedIssueEvent`
     * @throws ClassCastException if the instance is not `RenamedIssueEvent`
     */
    public RenamedIssueEvent getRenamedIssueEvent() throws ClassCastException {
        return (RenamedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ReviewDismissedIssueEvent`. If the actual instance is not `ReviewDismissedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ReviewDismissedIssueEvent`
     * @throws ClassCastException if the instance is not `ReviewDismissedIssueEvent`
     */
    public ReviewDismissedIssueEvent getReviewDismissedIssueEvent() throws ClassCastException {
        return (ReviewDismissedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ReviewRequestRemovedIssueEvent`. If the actual instance is not `ReviewRequestRemovedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ReviewRequestRemovedIssueEvent`
     * @throws ClassCastException if the instance is not `ReviewRequestRemovedIssueEvent`
     */
    public ReviewRequestRemovedIssueEvent getReviewRequestRemovedIssueEvent() throws ClassCastException {
        return (ReviewRequestRemovedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ReviewRequestedIssueEvent`. If the actual instance is not `ReviewRequestedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ReviewRequestedIssueEvent`
     * @throws ClassCastException if the instance is not `ReviewRequestedIssueEvent`
     */
    public ReviewRequestedIssueEvent getReviewRequestedIssueEvent() throws ClassCastException {
        return (ReviewRequestedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `StateChangeIssueEvent`. If the actual instance is not `StateChangeIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `StateChangeIssueEvent`
     * @throws ClassCastException if the instance is not `StateChangeIssueEvent`
     */
    public StateChangeIssueEvent getStateChangeIssueEvent() throws ClassCastException {
        return (StateChangeIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TimelineAssignedIssueEvent`. If the actual instance is not `TimelineAssignedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TimelineAssignedIssueEvent`
     * @throws ClassCastException if the instance is not `TimelineAssignedIssueEvent`
     */
    public TimelineAssignedIssueEvent getTimelineAssignedIssueEvent() throws ClassCastException {
        return (TimelineAssignedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TimelineCommentEvent`. If the actual instance is not `TimelineCommentEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TimelineCommentEvent`
     * @throws ClassCastException if the instance is not `TimelineCommentEvent`
     */
    public TimelineCommentEvent getTimelineCommentEvent() throws ClassCastException {
        return (TimelineCommentEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TimelineCommitCommentedEvent`. If the actual instance is not `TimelineCommitCommentedEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TimelineCommitCommentedEvent`
     * @throws ClassCastException if the instance is not `TimelineCommitCommentedEvent`
     */
    public TimelineCommitCommentedEvent getTimelineCommitCommentedEvent() throws ClassCastException {
        return (TimelineCommitCommentedEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TimelineCommittedEvent`. If the actual instance is not `TimelineCommittedEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TimelineCommittedEvent`
     * @throws ClassCastException if the instance is not `TimelineCommittedEvent`
     */
    public TimelineCommittedEvent getTimelineCommittedEvent() throws ClassCastException {
        return (TimelineCommittedEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TimelineCrossReferencedEvent`. If the actual instance is not `TimelineCrossReferencedEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TimelineCrossReferencedEvent`
     * @throws ClassCastException if the instance is not `TimelineCrossReferencedEvent`
     */
    public TimelineCrossReferencedEvent getTimelineCrossReferencedEvent() throws ClassCastException {
        return (TimelineCrossReferencedEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TimelineLineCommentedEvent`. If the actual instance is not `TimelineLineCommentedEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TimelineLineCommentedEvent`
     * @throws ClassCastException if the instance is not `TimelineLineCommentedEvent`
     */
    public TimelineLineCommentedEvent getTimelineLineCommentedEvent() throws ClassCastException {
        return (TimelineLineCommentedEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TimelineReviewedEvent`. If the actual instance is not `TimelineReviewedEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TimelineReviewedEvent`
     * @throws ClassCastException if the instance is not `TimelineReviewedEvent`
     */
    public TimelineReviewedEvent getTimelineReviewedEvent() throws ClassCastException {
        return (TimelineReviewedEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TimelineUnassignedIssueEvent`. If the actual instance is not `TimelineUnassignedIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TimelineUnassignedIssueEvent`
     * @throws ClassCastException if the instance is not `TimelineUnassignedIssueEvent`
     */
    public TimelineUnassignedIssueEvent getTimelineUnassignedIssueEvent() throws ClassCastException {
        return (TimelineUnassignedIssueEvent)super.getActualInstance();
    }

    /**
     * Get the actual instance of `UnlabeledIssueEvent`. If the actual instance is not `UnlabeledIssueEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `UnlabeledIssueEvent`
     * @throws ClassCastException if the instance is not `UnlabeledIssueEvent`
     */
    public UnlabeledIssueEvent getUnlabeledIssueEvent() throws ClassCastException {
        return (UnlabeledIssueEvent)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TimelineIssueEvents
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate anyOf schemas one by one
    int validCount = 0;
    // validate the json string with AddedToProjectIssueEvent
    try {
      AddedToProjectIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with ConvertedNoteToIssueIssueEvent
    try {
      ConvertedNoteToIssueIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with DemilestonedIssueEvent
    try {
      DemilestonedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with LabeledIssueEvent
    try {
      LabeledIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with LockedIssueEvent
    try {
      LockedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with MilestonedIssueEvent
    try {
      MilestonedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with MovedColumnInProjectIssueEvent
    try {
      MovedColumnInProjectIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with RemovedFromProjectIssueEvent
    try {
      RemovedFromProjectIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with RenamedIssueEvent
    try {
      RenamedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with ReviewDismissedIssueEvent
    try {
      ReviewDismissedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with ReviewRequestRemovedIssueEvent
    try {
      ReviewRequestRemovedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with ReviewRequestedIssueEvent
    try {
      ReviewRequestedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with StateChangeIssueEvent
    try {
      StateChangeIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with TimelineAssignedIssueEvent
    try {
      TimelineAssignedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with TimelineCommentEvent
    try {
      TimelineCommentEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with TimelineCommitCommentedEvent
    try {
      TimelineCommitCommentedEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with TimelineCommittedEvent
    try {
      TimelineCommittedEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with TimelineCrossReferencedEvent
    try {
      TimelineCrossReferencedEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with TimelineLineCommentedEvent
    try {
      TimelineLineCommentedEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with TimelineReviewedEvent
    try {
      TimelineReviewedEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with TimelineUnassignedIssueEvent
    try {
      TimelineUnassignedIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with UnlabeledIssueEvent
    try {
      UnlabeledIssueEvent.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    if (validCount == 0) {
      throw new IOException(String.format("The JSON string is invalid for TimelineIssueEvents with anyOf schemas: AddedToProjectIssueEvent, ConvertedNoteToIssueIssueEvent, DemilestonedIssueEvent, LabeledIssueEvent, LockedIssueEvent, MilestonedIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, RenamedIssueEvent, ReviewDismissedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewRequestedIssueEvent, StateChangeIssueEvent, TimelineAssignedIssueEvent, TimelineCommentEvent, TimelineCommitCommentedEvent, TimelineCommittedEvent, TimelineCrossReferencedEvent, TimelineLineCommentedEvent, TimelineReviewedEvent, TimelineUnassignedIssueEvent, UnlabeledIssueEvent. JSON: %s", jsonObj.toString()));
    }
  }

 /**
  * Create an instance of TimelineIssueEvents given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TimelineIssueEvents
  * @throws IOException if the JSON string is invalid with respect to TimelineIssueEvents
  */
  public static TimelineIssueEvents fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TimelineIssueEvents.class);
  }

 /**
  * Convert an instance of TimelineIssueEvents to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

