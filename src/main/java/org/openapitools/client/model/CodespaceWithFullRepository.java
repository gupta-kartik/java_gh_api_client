/*
 * GitHub v3 REST API
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.client.model.CodespaceGitStatus;
import org.openapitools.client.model.CodespaceRuntimeConstraints;
import org.openapitools.client.model.FullRepository;
import org.openapitools.client.model.NullableCodespaceMachine;
import org.openapitools.client.model.SimpleUser;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A codespace.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-05-09T20:37:23.111113500+10:00[Australia/Brisbane]")
public class CodespaceWithFullRepository {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "display_name";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_ENVIRONMENT_ID = "environment_id";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT_ID)
  private String environmentId;

  public static final String SERIALIZED_NAME_OWNER = "owner";
  @SerializedName(SERIALIZED_NAME_OWNER)
  private SimpleUser owner;

  public static final String SERIALIZED_NAME_BILLABLE_OWNER = "billable_owner";
  @SerializedName(SERIALIZED_NAME_BILLABLE_OWNER)
  private SimpleUser billableOwner;

  public static final String SERIALIZED_NAME_REPOSITORY = "repository";
  @SerializedName(SERIALIZED_NAME_REPOSITORY)
  private FullRepository repository;

  public static final String SERIALIZED_NAME_MACHINE = "machine";
  @SerializedName(SERIALIZED_NAME_MACHINE)
  private NullableCodespaceMachine machine;

  public static final String SERIALIZED_NAME_DEVCONTAINER_PATH = "devcontainer_path";
  @SerializedName(SERIALIZED_NAME_DEVCONTAINER_PATH)
  private String devcontainerPath;

  public static final String SERIALIZED_NAME_PREBUILD = "prebuild";
  @SerializedName(SERIALIZED_NAME_PREBUILD)
  private Boolean prebuild;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_LAST_USED_AT = "last_used_at";
  @SerializedName(SERIALIZED_NAME_LAST_USED_AT)
  private OffsetDateTime lastUsedAt;

  /**
   * State of this codespace.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    UNKNOWN("Unknown"),
    
    CREATED("Created"),
    
    QUEUED("Queued"),
    
    PROVISIONING("Provisioning"),
    
    AVAILABLE("Available"),
    
    AWAITING("Awaiting"),
    
    UNAVAILABLE("Unavailable"),
    
    DELETED("Deleted"),
    
    MOVED("Moved"),
    
    SHUTDOWN("Shutdown"),
    
    ARCHIVED("Archived"),
    
    STARTING("Starting"),
    
    SHUTTINGDOWN("ShuttingDown"),
    
    FAILED("Failed"),
    
    EXPORTING("Exporting"),
    
    UPDATING("Updating"),
    
    REBUILDING("Rebuilding");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private URI url;

  public static final String SERIALIZED_NAME_GIT_STATUS = "git_status";
  @SerializedName(SERIALIZED_NAME_GIT_STATUS)
  private CodespaceGitStatus gitStatus;

  /**
   * The initally assigned location of a new codespace.
   */
  @JsonAdapter(LocationEnum.Adapter.class)
  public enum LocationEnum {
    EASTUS("EastUs"),
    
    SOUTHEASTASIA("SouthEastAsia"),
    
    WESTEUROPE("WestEurope"),
    
    WESTUS2("WestUs2");

    private String value;

    LocationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LocationEnum fromValue(String value) {
      for (LocationEnum b : LocationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LocationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LocationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LocationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LocationEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private LocationEnum location;

  public static final String SERIALIZED_NAME_IDLE_TIMEOUT_MINUTES = "idle_timeout_minutes";
  @SerializedName(SERIALIZED_NAME_IDLE_TIMEOUT_MINUTES)
  private Integer idleTimeoutMinutes;

  public static final String SERIALIZED_NAME_WEB_URL = "web_url";
  @SerializedName(SERIALIZED_NAME_WEB_URL)
  private URI webUrl;

  public static final String SERIALIZED_NAME_MACHINES_URL = "machines_url";
  @SerializedName(SERIALIZED_NAME_MACHINES_URL)
  private URI machinesUrl;

  public static final String SERIALIZED_NAME_START_URL = "start_url";
  @SerializedName(SERIALIZED_NAME_START_URL)
  private URI startUrl;

  public static final String SERIALIZED_NAME_STOP_URL = "stop_url";
  @SerializedName(SERIALIZED_NAME_STOP_URL)
  private URI stopUrl;

  public static final String SERIALIZED_NAME_PUBLISH_URL = "publish_url";
  @SerializedName(SERIALIZED_NAME_PUBLISH_URL)
  private URI publishUrl;

  public static final String SERIALIZED_NAME_PULLS_URL = "pulls_url";
  @SerializedName(SERIALIZED_NAME_PULLS_URL)
  private URI pullsUrl;

  public static final String SERIALIZED_NAME_RECENT_FOLDERS = "recent_folders";
  @SerializedName(SERIALIZED_NAME_RECENT_FOLDERS)
  private List<String> recentFolders = new ArrayList<>();

  public static final String SERIALIZED_NAME_RUNTIME_CONSTRAINTS = "runtime_constraints";
  @SerializedName(SERIALIZED_NAME_RUNTIME_CONSTRAINTS)
  private CodespaceRuntimeConstraints runtimeConstraints;

  public static final String SERIALIZED_NAME_PENDING_OPERATION = "pending_operation";
  @SerializedName(SERIALIZED_NAME_PENDING_OPERATION)
  private Boolean pendingOperation;

  public static final String SERIALIZED_NAME_PENDING_OPERATION_DISABLED_REASON = "pending_operation_disabled_reason";
  @SerializedName(SERIALIZED_NAME_PENDING_OPERATION_DISABLED_REASON)
  private String pendingOperationDisabledReason;

  public static final String SERIALIZED_NAME_IDLE_TIMEOUT_NOTICE = "idle_timeout_notice";
  @SerializedName(SERIALIZED_NAME_IDLE_TIMEOUT_NOTICE)
  private String idleTimeoutNotice;

  public static final String SERIALIZED_NAME_RETENTION_PERIOD_MINUTES = "retention_period_minutes";
  @SerializedName(SERIALIZED_NAME_RETENTION_PERIOD_MINUTES)
  private Integer retentionPeriodMinutes;

  public static final String SERIALIZED_NAME_RETENTION_EXPIRES_AT = "retention_expires_at";
  @SerializedName(SERIALIZED_NAME_RETENTION_EXPIRES_AT)
  private OffsetDateTime retentionExpiresAt;

  public CodespaceWithFullRepository() {
  }

  public CodespaceWithFullRepository id(Integer id) {
    
    this.id = id;
    return this;
  }

   /**
   * Get id
   * @return id
  **/
  @javax.annotation.Nonnull

  public Integer getId() {
    return id;
  }


  public void setId(Integer id) {
    this.id = id;
  }


  public CodespaceWithFullRepository name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Automatically generated name of this codespace.
   * @return name
  **/
  @javax.annotation.Nonnull

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public CodespaceWithFullRepository displayName(String displayName) {
    
    this.displayName = displayName;
    return this;
  }

   /**
   * Display name for this codespace.
   * @return displayName
  **/
  @javax.annotation.Nullable

  public String getDisplayName() {
    return displayName;
  }


  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public CodespaceWithFullRepository environmentId(String environmentId) {
    
    this.environmentId = environmentId;
    return this;
  }

   /**
   * UUID identifying this codespace&#39;s environment.
   * @return environmentId
  **/
  @javax.annotation.Nullable

  public String getEnvironmentId() {
    return environmentId;
  }


  public void setEnvironmentId(String environmentId) {
    this.environmentId = environmentId;
  }


  public CodespaceWithFullRepository owner(SimpleUser owner) {
    
    this.owner = owner;
    return this;
  }

   /**
   * Get owner
   * @return owner
  **/
  @javax.annotation.Nonnull

  public SimpleUser getOwner() {
    return owner;
  }


  public void setOwner(SimpleUser owner) {
    this.owner = owner;
  }


  public CodespaceWithFullRepository billableOwner(SimpleUser billableOwner) {
    
    this.billableOwner = billableOwner;
    return this;
  }

   /**
   * Get billableOwner
   * @return billableOwner
  **/
  @javax.annotation.Nonnull

  public SimpleUser getBillableOwner() {
    return billableOwner;
  }


  public void setBillableOwner(SimpleUser billableOwner) {
    this.billableOwner = billableOwner;
  }


  public CodespaceWithFullRepository repository(FullRepository repository) {
    
    this.repository = repository;
    return this;
  }

   /**
   * Get repository
   * @return repository
  **/
  @javax.annotation.Nonnull

  public FullRepository getRepository() {
    return repository;
  }


  public void setRepository(FullRepository repository) {
    this.repository = repository;
  }


  public CodespaceWithFullRepository machine(NullableCodespaceMachine machine) {
    
    this.machine = machine;
    return this;
  }

   /**
   * Get machine
   * @return machine
  **/
  @javax.annotation.Nullable

  public NullableCodespaceMachine getMachine() {
    return machine;
  }


  public void setMachine(NullableCodespaceMachine machine) {
    this.machine = machine;
  }


  public CodespaceWithFullRepository devcontainerPath(String devcontainerPath) {
    
    this.devcontainerPath = devcontainerPath;
    return this;
  }

   /**
   * Path to devcontainer.json from repo root used to create Codespace.
   * @return devcontainerPath
  **/
  @javax.annotation.Nullable

  public String getDevcontainerPath() {
    return devcontainerPath;
  }


  public void setDevcontainerPath(String devcontainerPath) {
    this.devcontainerPath = devcontainerPath;
  }


  public CodespaceWithFullRepository prebuild(Boolean prebuild) {
    
    this.prebuild = prebuild;
    return this;
  }

   /**
   * Whether the codespace was created from a prebuild.
   * @return prebuild
  **/
  @javax.annotation.Nullable

  public Boolean getPrebuild() {
    return prebuild;
  }


  public void setPrebuild(Boolean prebuild) {
    this.prebuild = prebuild;
  }


  public CodespaceWithFullRepository createdAt(OffsetDateTime createdAt) {
    
    this.createdAt = createdAt;
    return this;
  }

   /**
   * Get createdAt
   * @return createdAt
  **/
  @javax.annotation.Nonnull

  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }


  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public CodespaceWithFullRepository updatedAt(OffsetDateTime updatedAt) {
    
    this.updatedAt = updatedAt;
    return this;
  }

   /**
   * Get updatedAt
   * @return updatedAt
  **/
  @javax.annotation.Nonnull

  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }


  public void setUpdatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
  }


  public CodespaceWithFullRepository lastUsedAt(OffsetDateTime lastUsedAt) {
    
    this.lastUsedAt = lastUsedAt;
    return this;
  }

   /**
   * Last known time this codespace was started.
   * @return lastUsedAt
  **/
  @javax.annotation.Nonnull

  public OffsetDateTime getLastUsedAt() {
    return lastUsedAt;
  }


  public void setLastUsedAt(OffsetDateTime lastUsedAt) {
    this.lastUsedAt = lastUsedAt;
  }


  public CodespaceWithFullRepository state(StateEnum state) {
    
    this.state = state;
    return this;
  }

   /**
   * State of this codespace.
   * @return state
  **/
  @javax.annotation.Nonnull

  public StateEnum getState() {
    return state;
  }


  public void setState(StateEnum state) {
    this.state = state;
  }


  public CodespaceWithFullRepository url(URI url) {
    
    this.url = url;
    return this;
  }

   /**
   * API URL for this codespace.
   * @return url
  **/
  @javax.annotation.Nonnull

  public URI getUrl() {
    return url;
  }


  public void setUrl(URI url) {
    this.url = url;
  }


  public CodespaceWithFullRepository gitStatus(CodespaceGitStatus gitStatus) {
    
    this.gitStatus = gitStatus;
    return this;
  }

   /**
   * Get gitStatus
   * @return gitStatus
  **/
  @javax.annotation.Nonnull

  public CodespaceGitStatus getGitStatus() {
    return gitStatus;
  }


  public void setGitStatus(CodespaceGitStatus gitStatus) {
    this.gitStatus = gitStatus;
  }


  public CodespaceWithFullRepository location(LocationEnum location) {
    
    this.location = location;
    return this;
  }

   /**
   * The initally assigned location of a new codespace.
   * @return location
  **/
  @javax.annotation.Nonnull

  public LocationEnum getLocation() {
    return location;
  }


  public void setLocation(LocationEnum location) {
    this.location = location;
  }


  public CodespaceWithFullRepository idleTimeoutMinutes(Integer idleTimeoutMinutes) {
    
    this.idleTimeoutMinutes = idleTimeoutMinutes;
    return this;
  }

   /**
   * The number of minutes of inactivity after which this codespace will be automatically stopped.
   * @return idleTimeoutMinutes
  **/
  @javax.annotation.Nullable

  public Integer getIdleTimeoutMinutes() {
    return idleTimeoutMinutes;
  }


  public void setIdleTimeoutMinutes(Integer idleTimeoutMinutes) {
    this.idleTimeoutMinutes = idleTimeoutMinutes;
  }


  public CodespaceWithFullRepository webUrl(URI webUrl) {
    
    this.webUrl = webUrl;
    return this;
  }

   /**
   * URL to access this codespace on the web.
   * @return webUrl
  **/
  @javax.annotation.Nonnull

  public URI getWebUrl() {
    return webUrl;
  }


  public void setWebUrl(URI webUrl) {
    this.webUrl = webUrl;
  }


  public CodespaceWithFullRepository machinesUrl(URI machinesUrl) {
    
    this.machinesUrl = machinesUrl;
    return this;
  }

   /**
   * API URL to access available alternate machine types for this codespace.
   * @return machinesUrl
  **/
  @javax.annotation.Nonnull

  public URI getMachinesUrl() {
    return machinesUrl;
  }


  public void setMachinesUrl(URI machinesUrl) {
    this.machinesUrl = machinesUrl;
  }


  public CodespaceWithFullRepository startUrl(URI startUrl) {
    
    this.startUrl = startUrl;
    return this;
  }

   /**
   * API URL to start this codespace.
   * @return startUrl
  **/
  @javax.annotation.Nonnull

  public URI getStartUrl() {
    return startUrl;
  }


  public void setStartUrl(URI startUrl) {
    this.startUrl = startUrl;
  }


  public CodespaceWithFullRepository stopUrl(URI stopUrl) {
    
    this.stopUrl = stopUrl;
    return this;
  }

   /**
   * API URL to stop this codespace.
   * @return stopUrl
  **/
  @javax.annotation.Nonnull

  public URI getStopUrl() {
    return stopUrl;
  }


  public void setStopUrl(URI stopUrl) {
    this.stopUrl = stopUrl;
  }


  public CodespaceWithFullRepository publishUrl(URI publishUrl) {
    
    this.publishUrl = publishUrl;
    return this;
  }

   /**
   * API URL to publish this codespace to a new repository.
   * @return publishUrl
  **/
  @javax.annotation.Nullable

  public URI getPublishUrl() {
    return publishUrl;
  }


  public void setPublishUrl(URI publishUrl) {
    this.publishUrl = publishUrl;
  }


  public CodespaceWithFullRepository pullsUrl(URI pullsUrl) {
    
    this.pullsUrl = pullsUrl;
    return this;
  }

   /**
   * API URL for the Pull Request associated with this codespace, if any.
   * @return pullsUrl
  **/
  @javax.annotation.Nullable

  public URI getPullsUrl() {
    return pullsUrl;
  }


  public void setPullsUrl(URI pullsUrl) {
    this.pullsUrl = pullsUrl;
  }


  public CodespaceWithFullRepository recentFolders(List<String> recentFolders) {
    
    this.recentFolders = recentFolders;
    return this;
  }

  public CodespaceWithFullRepository addRecentFoldersItem(String recentFoldersItem) {
    if (this.recentFolders == null) {
      this.recentFolders = new ArrayList<>();
    }
    this.recentFolders.add(recentFoldersItem);
    return this;
  }

   /**
   * Get recentFolders
   * @return recentFolders
  **/
  @javax.annotation.Nonnull

  public List<String> getRecentFolders() {
    return recentFolders;
  }


  public void setRecentFolders(List<String> recentFolders) {
    this.recentFolders = recentFolders;
  }


  public CodespaceWithFullRepository runtimeConstraints(CodespaceRuntimeConstraints runtimeConstraints) {
    
    this.runtimeConstraints = runtimeConstraints;
    return this;
  }

   /**
   * Get runtimeConstraints
   * @return runtimeConstraints
  **/
  @javax.annotation.Nullable

  public CodespaceRuntimeConstraints getRuntimeConstraints() {
    return runtimeConstraints;
  }


  public void setRuntimeConstraints(CodespaceRuntimeConstraints runtimeConstraints) {
    this.runtimeConstraints = runtimeConstraints;
  }


  public CodespaceWithFullRepository pendingOperation(Boolean pendingOperation) {
    
    this.pendingOperation = pendingOperation;
    return this;
  }

   /**
   * Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.
   * @return pendingOperation
  **/
  @javax.annotation.Nullable

  public Boolean getPendingOperation() {
    return pendingOperation;
  }


  public void setPendingOperation(Boolean pendingOperation) {
    this.pendingOperation = pendingOperation;
  }


  public CodespaceWithFullRepository pendingOperationDisabledReason(String pendingOperationDisabledReason) {
    
    this.pendingOperationDisabledReason = pendingOperationDisabledReason;
    return this;
  }

   /**
   * Text to show user when codespace is disabled by a pending operation
   * @return pendingOperationDisabledReason
  **/
  @javax.annotation.Nullable

  public String getPendingOperationDisabledReason() {
    return pendingOperationDisabledReason;
  }


  public void setPendingOperationDisabledReason(String pendingOperationDisabledReason) {
    this.pendingOperationDisabledReason = pendingOperationDisabledReason;
  }


  public CodespaceWithFullRepository idleTimeoutNotice(String idleTimeoutNotice) {
    
    this.idleTimeoutNotice = idleTimeoutNotice;
    return this;
  }

   /**
   * Text to show user when codespace idle timeout minutes has been overriden by an organization policy
   * @return idleTimeoutNotice
  **/
  @javax.annotation.Nullable

  public String getIdleTimeoutNotice() {
    return idleTimeoutNotice;
  }


  public void setIdleTimeoutNotice(String idleTimeoutNotice) {
    this.idleTimeoutNotice = idleTimeoutNotice;
  }


  public CodespaceWithFullRepository retentionPeriodMinutes(Integer retentionPeriodMinutes) {
    
    this.retentionPeriodMinutes = retentionPeriodMinutes;
    return this;
  }

   /**
   * Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
   * @return retentionPeriodMinutes
  **/
  @javax.annotation.Nullable

  public Integer getRetentionPeriodMinutes() {
    return retentionPeriodMinutes;
  }


  public void setRetentionPeriodMinutes(Integer retentionPeriodMinutes) {
    this.retentionPeriodMinutes = retentionPeriodMinutes;
  }


  public CodespaceWithFullRepository retentionExpiresAt(OffsetDateTime retentionExpiresAt) {
    
    this.retentionExpiresAt = retentionExpiresAt;
    return this;
  }

   /**
   * When a codespace will be auto-deleted based on the \&quot;retention_period_minutes\&quot; and \&quot;last_used_at\&quot;
   * @return retentionExpiresAt
  **/
  @javax.annotation.Nullable

  public OffsetDateTime getRetentionExpiresAt() {
    return retentionExpiresAt;
  }


  public void setRetentionExpiresAt(OffsetDateTime retentionExpiresAt) {
    this.retentionExpiresAt = retentionExpiresAt;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CodespaceWithFullRepository codespaceWithFullRepository = (CodespaceWithFullRepository) o;
    return Objects.equals(this.id, codespaceWithFullRepository.id) &&
        Objects.equals(this.name, codespaceWithFullRepository.name) &&
        Objects.equals(this.displayName, codespaceWithFullRepository.displayName) &&
        Objects.equals(this.environmentId, codespaceWithFullRepository.environmentId) &&
        Objects.equals(this.owner, codespaceWithFullRepository.owner) &&
        Objects.equals(this.billableOwner, codespaceWithFullRepository.billableOwner) &&
        Objects.equals(this.repository, codespaceWithFullRepository.repository) &&
        Objects.equals(this.machine, codespaceWithFullRepository.machine) &&
        Objects.equals(this.devcontainerPath, codespaceWithFullRepository.devcontainerPath) &&
        Objects.equals(this.prebuild, codespaceWithFullRepository.prebuild) &&
        Objects.equals(this.createdAt, codespaceWithFullRepository.createdAt) &&
        Objects.equals(this.updatedAt, codespaceWithFullRepository.updatedAt) &&
        Objects.equals(this.lastUsedAt, codespaceWithFullRepository.lastUsedAt) &&
        Objects.equals(this.state, codespaceWithFullRepository.state) &&
        Objects.equals(this.url, codespaceWithFullRepository.url) &&
        Objects.equals(this.gitStatus, codespaceWithFullRepository.gitStatus) &&
        Objects.equals(this.location, codespaceWithFullRepository.location) &&
        Objects.equals(this.idleTimeoutMinutes, codespaceWithFullRepository.idleTimeoutMinutes) &&
        Objects.equals(this.webUrl, codespaceWithFullRepository.webUrl) &&
        Objects.equals(this.machinesUrl, codespaceWithFullRepository.machinesUrl) &&
        Objects.equals(this.startUrl, codespaceWithFullRepository.startUrl) &&
        Objects.equals(this.stopUrl, codespaceWithFullRepository.stopUrl) &&
        Objects.equals(this.publishUrl, codespaceWithFullRepository.publishUrl) &&
        Objects.equals(this.pullsUrl, codespaceWithFullRepository.pullsUrl) &&
        Objects.equals(this.recentFolders, codespaceWithFullRepository.recentFolders) &&
        Objects.equals(this.runtimeConstraints, codespaceWithFullRepository.runtimeConstraints) &&
        Objects.equals(this.pendingOperation, codespaceWithFullRepository.pendingOperation) &&
        Objects.equals(this.pendingOperationDisabledReason, codespaceWithFullRepository.pendingOperationDisabledReason) &&
        Objects.equals(this.idleTimeoutNotice, codespaceWithFullRepository.idleTimeoutNotice) &&
        Objects.equals(this.retentionPeriodMinutes, codespaceWithFullRepository.retentionPeriodMinutes) &&
        Objects.equals(this.retentionExpiresAt, codespaceWithFullRepository.retentionExpiresAt);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, displayName, environmentId, owner, billableOwner, repository, machine, devcontainerPath, prebuild, createdAt, updatedAt, lastUsedAt, state, url, gitStatus, location, idleTimeoutMinutes, webUrl, machinesUrl, startUrl, stopUrl, publishUrl, pullsUrl, recentFolders, runtimeConstraints, pendingOperation, pendingOperationDisabledReason, idleTimeoutNotice, retentionPeriodMinutes, retentionExpiresAt);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CodespaceWithFullRepository {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    environmentId: ").append(toIndentedString(environmentId)).append("\n");
    sb.append("    owner: ").append(toIndentedString(owner)).append("\n");
    sb.append("    billableOwner: ").append(toIndentedString(billableOwner)).append("\n");
    sb.append("    repository: ").append(toIndentedString(repository)).append("\n");
    sb.append("    machine: ").append(toIndentedString(machine)).append("\n");
    sb.append("    devcontainerPath: ").append(toIndentedString(devcontainerPath)).append("\n");
    sb.append("    prebuild: ").append(toIndentedString(prebuild)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    lastUsedAt: ").append(toIndentedString(lastUsedAt)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    gitStatus: ").append(toIndentedString(gitStatus)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    idleTimeoutMinutes: ").append(toIndentedString(idleTimeoutMinutes)).append("\n");
    sb.append("    webUrl: ").append(toIndentedString(webUrl)).append("\n");
    sb.append("    machinesUrl: ").append(toIndentedString(machinesUrl)).append("\n");
    sb.append("    startUrl: ").append(toIndentedString(startUrl)).append("\n");
    sb.append("    stopUrl: ").append(toIndentedString(stopUrl)).append("\n");
    sb.append("    publishUrl: ").append(toIndentedString(publishUrl)).append("\n");
    sb.append("    pullsUrl: ").append(toIndentedString(pullsUrl)).append("\n");
    sb.append("    recentFolders: ").append(toIndentedString(recentFolders)).append("\n");
    sb.append("    runtimeConstraints: ").append(toIndentedString(runtimeConstraints)).append("\n");
    sb.append("    pendingOperation: ").append(toIndentedString(pendingOperation)).append("\n");
    sb.append("    pendingOperationDisabledReason: ").append(toIndentedString(pendingOperationDisabledReason)).append("\n");
    sb.append("    idleTimeoutNotice: ").append(toIndentedString(idleTimeoutNotice)).append("\n");
    sb.append("    retentionPeriodMinutes: ").append(toIndentedString(retentionPeriodMinutes)).append("\n");
    sb.append("    retentionExpiresAt: ").append(toIndentedString(retentionExpiresAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("name");
    openapiFields.add("display_name");
    openapiFields.add("environment_id");
    openapiFields.add("owner");
    openapiFields.add("billable_owner");
    openapiFields.add("repository");
    openapiFields.add("machine");
    openapiFields.add("devcontainer_path");
    openapiFields.add("prebuild");
    openapiFields.add("created_at");
    openapiFields.add("updated_at");
    openapiFields.add("last_used_at");
    openapiFields.add("state");
    openapiFields.add("url");
    openapiFields.add("git_status");
    openapiFields.add("location");
    openapiFields.add("idle_timeout_minutes");
    openapiFields.add("web_url");
    openapiFields.add("machines_url");
    openapiFields.add("start_url");
    openapiFields.add("stop_url");
    openapiFields.add("publish_url");
    openapiFields.add("pulls_url");
    openapiFields.add("recent_folders");
    openapiFields.add("runtime_constraints");
    openapiFields.add("pending_operation");
    openapiFields.add("pending_operation_disabled_reason");
    openapiFields.add("idle_timeout_notice");
    openapiFields.add("retention_period_minutes");
    openapiFields.add("retention_expires_at");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("environment_id");
    openapiRequiredFields.add("owner");
    openapiRequiredFields.add("billable_owner");
    openapiRequiredFields.add("repository");
    openapiRequiredFields.add("machine");
    openapiRequiredFields.add("prebuild");
    openapiRequiredFields.add("created_at");
    openapiRequiredFields.add("updated_at");
    openapiRequiredFields.add("last_used_at");
    openapiRequiredFields.add("state");
    openapiRequiredFields.add("url");
    openapiRequiredFields.add("git_status");
    openapiRequiredFields.add("location");
    openapiRequiredFields.add("idle_timeout_minutes");
    openapiRequiredFields.add("web_url");
    openapiRequiredFields.add("machines_url");
    openapiRequiredFields.add("start_url");
    openapiRequiredFields.add("stop_url");
    openapiRequiredFields.add("pulls_url");
    openapiRequiredFields.add("recent_folders");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to CodespaceWithFullRepository
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!CodespaceWithFullRepository.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CodespaceWithFullRepository is not found in the empty JSON string", CodespaceWithFullRepository.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!CodespaceWithFullRepository.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CodespaceWithFullRepository` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CodespaceWithFullRepository.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("display_name") != null && !jsonObj.get("display_name").isJsonNull()) && !jsonObj.get("display_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `display_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("display_name").toString()));
      }
      if (!jsonObj.get("environment_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `environment_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("environment_id").toString()));
      }
      // validate the required field `owner`
      SimpleUser.validateJsonObject(jsonObj.getAsJsonObject("owner"));
      // validate the required field `billable_owner`
      SimpleUser.validateJsonObject(jsonObj.getAsJsonObject("billable_owner"));
      // validate the required field `repository`
      FullRepository.validateJsonObject(jsonObj.getAsJsonObject("repository"));
      // validate the required field `machine`
      NullableCodespaceMachine.validateJsonObject(jsonObj.getAsJsonObject("machine"));
      if ((jsonObj.get("devcontainer_path") != null && !jsonObj.get("devcontainer_path").isJsonNull()) && !jsonObj.get("devcontainer_path").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `devcontainer_path` to be a primitive type in the JSON string but got `%s`", jsonObj.get("devcontainer_path").toString()));
      }
      if (!jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      // validate the required field `git_status`
      CodespaceGitStatus.validateJsonObject(jsonObj.getAsJsonObject("git_status"));
      if (!jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      if (!jsonObj.get("web_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `web_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("web_url").toString()));
      }
      if (!jsonObj.get("machines_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machines_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machines_url").toString()));
      }
      if (!jsonObj.get("start_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `start_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("start_url").toString()));
      }
      if (!jsonObj.get("stop_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stop_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stop_url").toString()));
      }
      if ((jsonObj.get("publish_url") != null && !jsonObj.get("publish_url").isJsonNull()) && !jsonObj.get("publish_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publish_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publish_url").toString()));
      }
      if (!jsonObj.get("pulls_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pulls_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pulls_url").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("recent_folders") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("recent_folders").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `recent_folders` to be an array in the JSON string but got `%s`", jsonObj.get("recent_folders").toString()));
      }
      // validate the optional field `runtime_constraints`
      if (jsonObj.get("runtime_constraints") != null && !jsonObj.get("runtime_constraints").isJsonNull()) {
        CodespaceRuntimeConstraints.validateJsonObject(jsonObj.getAsJsonObject("runtime_constraints"));
      }
      if ((jsonObj.get("pending_operation_disabled_reason") != null && !jsonObj.get("pending_operation_disabled_reason").isJsonNull()) && !jsonObj.get("pending_operation_disabled_reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pending_operation_disabled_reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pending_operation_disabled_reason").toString()));
      }
      if ((jsonObj.get("idle_timeout_notice") != null && !jsonObj.get("idle_timeout_notice").isJsonNull()) && !jsonObj.get("idle_timeout_notice").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `idle_timeout_notice` to be a primitive type in the JSON string but got `%s`", jsonObj.get("idle_timeout_notice").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CodespaceWithFullRepository.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CodespaceWithFullRepository' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CodespaceWithFullRepository> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CodespaceWithFullRepository.class));

       return (TypeAdapter<T>) new TypeAdapter<CodespaceWithFullRepository>() {
           @Override
           public void write(JsonWriter out, CodespaceWithFullRepository value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CodespaceWithFullRepository read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of CodespaceWithFullRepository given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of CodespaceWithFullRepository
  * @throws IOException if the JSON string is invalid with respect to CodespaceWithFullRepository
  */
  public static CodespaceWithFullRepository fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CodespaceWithFullRepository.class);
  }

 /**
  * Convert an instance of CodespaceWithFullRepository to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

